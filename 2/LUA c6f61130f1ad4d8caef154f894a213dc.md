# LUA

LUA 언어는 가벼운 스크립트 프로그래밍 언어로, 주로 임베디드 시스템, 게임 개발, 웹 서버 스크립트 등에서 사용됩니다. 1993년 브라질의 리오데자네이루 카톨릭 대학에서 처음 개발되었으며, 그 목적은 강력하면서도 간단한 언어를 만드는 것이었습니다.

LUA는 특히 그 구조가 간결하여 배우기 쉽고, C 언어와의 호환성이 뛰어나 C 라이브러리와 쉽게 통합할 수 있습니다. 이러한 특징 덕분에 게임 엔진에서 스크립팅 언어로 널리 채택되었고, 대표적인 예로는 월드 오브 워크래프트, 안그리 버드, 로블록스 등이 있습니다.

LUA의 핵심 특징 중 하나는 확장성입니다. 루아는 데이터 설명, 구성, 프로토타이핑, 빠른 개발을 용이하게 하는 간단한 문법을 가지고 있으며, 메타메커니즘을 통해 언어 자체를 확장할 수 있습니다. 이는 개발자가 루아 자체의 구문을 확장하거나 변경할 수 있음을 의미합니다.

또한, LUA는 가벼운 메모리 사용량과 뛰어난 실행 속도로 인해 소규모 기기나 실시간 시스템에도 적합합니다. 이러한 특성 때문에 임베디드 시스템 또는 IoT 장치에서도 활용되고 있습니다.

## **기본 문법과 자료형**

### **1 변수와 자료형**

```lua
-- 변수 선언과 자료형
local number = 42              -- 숫자형
local string = "안녕하세요!"   -- 문자열
local boolean = true           -- 불리언
local nilValue = nil           -- nil

-- 변수 값 출력
print("숫자형 변수: ", number)
print("문자열 변수: ", string)
print("불리언 변수: ", boolean)
print("Nil 값 변수: ", nilValue)
```

- **변수 선언과 할당**: LUA에서는 **`local`** 키워드를 사용하여 지역 변수를 선언할 수 있습니다. 변수에 값을 할당할 때는 **`=`** 연산자를 사용합니다.
- **자료형**: LUA의 기본 자료형에는 숫자형, 문자열, 불리언, nil, 테이블, 함수, 스레드, 사용자 데이터가 있습니다.
    - **숫자형**: 정수와 실수를 포함합니다.
    - **문자열**: 큰따옴표(" ") 또는 작은따옴표(' ')로 묶인 문자들의 집합입니다.
    - **불리언**: **`true`** 또는 **`false`** 값을 가지며, 조건문에서 주로 사용됩니다.
    - **Nil**: 변수에 값이 없음을 나타내는 자료형으로, 주로 초기화되지 않은 변수에 사용됩니다.
- **숫자데이터**
    
    LUA는 내부적으로 숫자를 처리할 때 모든 숫자를 double-precision floating-point 형식으로 저장합니다. 이는 ANSI C의 **`double`** 자료형과 동일하며, 이러한 처리 방식은 여러 가지 측면에서 편리함을 제공하지만, 몇 가지 유의해야 할 점도 있습니다.
    
    **1. 정밀도와 범위**
    
    - **Double-precision floating-point**: 이 형식은 약 15-17자리의 정밀도를 제공합니다. 따라서 매우 큰 수나 매우 작은 수를 다룰 때 정밀도 손실이 발생할 수 있습니다. 예를 들어, 매우 큰 정수를 다루는 금융 분야에서는 정밀도 손실이 중요한 문제가 될 수 있습니다.
    - **범위**: Double 타입은 매우 넓은 수치 범위를 커버할 수 있으나, 최대/최소 범위를 넘어서는 수치에 대해 오버플로우 또는 언더플로우가 발생할 수 있습니다.
    
    **2. 정수 처리**
    
    - **정수 연산**: LUA에서는 모든 숫자를 실수로 처리하기 때문에, 전통적인 정수 연산(예: 비트 연산)이 필요할 때 문제가 발생할 수 있습니다. LUA 5.3 이상에서는 정수 자료형과 관련 연산자가 추가되어 이 문제를 해결하고 있습니다.
    - **정수와 실수의 구분**: 특정 버전 이전의 LUA에서는 정수와 실수를 구분하지 않았습니다. 이는 특정 연산에서 예상치 못한 결과를 초래할 수 있으므로, 연산의 정확성을 보장하려면 이 부분을 인식해야 합니다.
    
    **3. 연산 시 주의점**
    
    - **부동 소수점 연산**: 부동 소수점 연산은 정수 연산보다 느릴 수 있으며, 특히 루프 내에서 빈번하게 부동 소수점 연산을 수행할 경우 성능 저하가 발생할 수 있습니다.
    - **비교 연산**: 부동 소수점 수는 정확한 값 대신 근사치로 표현될 수 있기 때문에, 부동 소수점 수를 직접 비교할 때는 주의가 필요합니다. 예를 들어, **`0.1 + 0.2 == 0.3`**은 false가 될 수 있습니다.
    
    **4. 해결책과 대안**
    
    - **정수 사용**: LUA 5.3 이상을 사용하면 정수를 명시적으로 사용할 수 있어 이러한 문제를 해결할 수 있습니다. 예를 들어, 정수 연산을 수행하거나 정수 범위 내에서 변수를 사용해야 하는 경우 이를 명시적으로 처리할 수 있습니다.
    - **데이터 타입 명확화**: 필요한 경우 정수와 실수를 명확하게 구분하여 사용함으로써 오류를 예방할 수 있습니다.
    - **외부 라이브러리 사용**: 큰 정수를 정확하게 다루어야 할 경우, 외부 라이브러리를 사용하여 이 문제를 해결할 수도 있습니다.
    
    이러한 특성을 이해하고 적절히 대응함으로써, LUA 프로그래밍에서 발생할 수 있는 수치 처리 관련 이슈를 효과적으로 관리할 수 있습니다.
    

### **2 연산자**

- **산술 연산자**: **`+`**, **``**, **``**, **`/`**, **`%`** (나머지), **`^`** (지수)
- **비교 연산자**: **`==`** (같음), **`~=`** (같지 않음), **`<`**, **`>`**, **`<=`**, **`>=`**
- **논리 연산자**: **`and`**, **`or`**, **`not`**

### **3 제어 구조**

- **조건문**: **`if`** 문을 사용하여 조건에 따라 다른 코드를 실행할 수 있습니다. **`else`**와 **`elseif`**를 사용하여 추가 조건을 제공할 수 있습니다.
    
    ```lua
    if 조건1 then
        -- 조건1이 참일 때 실행
    elseif 조건2 then
        -- 조건2가 참일 때 실행
    else
        -- 모든 조건이 거짓일 때 실행
    end
    ```
    
- **LUA의 다중 조건**: LUA에서 다중 조건을 평가할 때는 **`and`**, **`or`**, **`not`** 등의 논리 연산자를 사용합니다. 이 연산자들을 조합하여 복잡한 조건을 구성할 수 있습니다.
    
    ```lua
    local age = 20
    local name = "Alice"
    
    if age > 18 and name == "Alice" then
        print("Hello, Alice. You are over 18.")
    elseif age < 18 and name == "Alice" then
        print("Hello, Alice. You are under 18.")
    else
        print("You are not Alice.")
    end
    ```
    
    이 예제에서는 **`age`**와 **`name`** 두 변수를 확인하여 복합적인 조건에 따라 다른 메시지를 출력합니다.
    
- **LUA에서 삼항 연산자 대체**: C#이나 C에서는 삼항 연산자(**`? :`**)를 사용하여 간단한 조건에 따라 값을 선택할 수 있습니다. LUA에서는 이와 같은 직접적인 삼항 연산자가 없지만, **`and`**와 **`or`**를 조합하여 유사한 결과를 얻을 수 있습니다.
    
    ```lua
    local age = 20
    local canVote = (age >= 18) and "Yes" or "No"
    print("Can vote: " .. canVote)
    ```
    
    여기서 **`(age >= 18) and "Yes" or "No"`**는 C#이나 C의 **`age >= 18 ? "Yes" : "No"`**와 같은 역할을 합니다. **`age >= 18`** 조건이 참이면 "Yes"가 선택되고, 그렇지 않으면 "No"가 선택됩니다. 이 표현은 LUA에서 "짧은 회로(short-circuit)" 평가를 사용합니다:
    
    - **`and`**는 왼쪽 항이 참일 때 오른쪽 값을 평가합니다.
    - **`or`**는 왼쪽 항이 거짓일 때만 오른쪽 값을 평가합니다.
    
    LUA에서 **`and`**와 **`or`**를 사용하여 삼항 연산자를 모방할 때는 반환되는 값들이 모두 불리언이 아니라는 점을 유의해야 합니다. 이 방식은 왼쪽 조건이 참일 경우 왼쪽 **`and`**의 결과를, 거짓일 경우 **`or`**의 오른쪽 결과를 반환합니다.
    
- **반복문**: **`while`**과 **`for`** 루프를 사용하여 코드 블록을 반복 실행할 수 있습니다.
    - **While 루프**: 조건이 참인 동안 반복
        
        ```lua
        while 조건 do
            -- 실행 코드
        end
        ```
        
    - **Numeric for 루프**: 시작 값, 종료 값, 증가량을 지정하여 반복
        
        ```lua
        for i = 1, 10, 1 do
            -- 실행 코드
        end
        ```
        
    - **Generic for 루프**: 테이블이나 배열을 순회
        
        ```lua
        for key, value in pairs(table) do
            -- 실행 코드
        end
        ```
        

### **4 함수**

- **기본 함수**
    
    **함수 정의**: **`function`** 키워드를 사용하여 함수를 정의합니다. 함수는 이름을 가질 수도 있고, 이름이 없는 익명 함수일 수도 있습니다.
    
    ```lua
    function greet(name)return "Hello, " .. name
    end
    ```
    
    **함수 호출**: 정의된 함수는 이름을 사용하여 호출할 수 있습니다. 익명 함수는 변수에 할당된 후 해당 변수를 통해 호출할 수 있습니다.
    
    ```lua
    print(greet("Alice"))
    ```
    
- **매개변수와 반환 값**
    
    **매개변수**: 함수는 매개변수를 통해 외부로부터 값을 받을 수 있습니다. LUA는 매개변수의 기본 값을 설정할 수 없지만, 함수 내에서 조건문을 사용하여 처리할 수 있습니다.
    
    **반환 값**: 함수는 **`return`** 키워드를 사용하여 값을 반환할 수 있습니다. 여러 값을 반환하는 것도 가능합니다.
    
    ```lua
    function userInfo(name, age)return name, age
    end
    local name, age = userInfo("Bob", 30)
    ```
    
- **고급 기능**
    
    **클로저와 스코프**: 내부 함수가 외부 함수의 지역 변수에 접근할 수 있으며, 이를 클로저라고 합니다. 이는 데이터를 캡슐화하고, 상태를 유지하는 함수를 생성할 수 있게 해줍니다.
    
    ```lua
    function counter()local count = 0
      return function ()
        count = count + 1
        return count
      end
    end
    local myCounter = counter()
    print(myCounter())  -- 1
    print(myCounter())  -- 2
    ```
    

## **테이블**

### **기본 사용**

- **테이블 생성과 접근**: 테이블은 **`{}`**를 사용하여 생성하며, **`table[key]`** 형식으로 접근합니다.
    
    ```lua
    local person = {name = "Alice", age = 25}
    print(person.name)  -- "Alice"
    ```
    

### **테이블 작업**

- **추가와 수정**: 테이블에 새로운 항목을 추가하거나 기존 항목을 수정할 수 있습니다.
    
    ```lua
    person.email = "alice@example.com"
    person.name = "Alice Cooper"
    ```
    
- **삭제**: **`nil`**을 사용하여 테이블 항목을 삭제할 수 있습니다.
    
    ```lua
    person.age = nil
    ```
    

LUA 프로그래밍 언어는 전통적인 배열 구조를 내장하고 있지 않습니다. 대신, "테이블"이라는 매우 유연한 데이터 구조를 사용하여 배열과 같은 데이터 컬렉션을 모방합니다. 테이블은 키-값 쌍의 형태로 데이터를 저장하며, 이 구조는 배열, 딕셔너리, 객체 등 다양한 형태로 사용될 수 있습니다.

### **테이블과 함수**

**테이블을 사용한 모듈화**: 테이블은 함수를 포함할 수 있어, 객체 지향 프로그래밍 패턴을 흉내 내는데 사용될 수 있습니다.

```lua
function person.greet(self)return "Hello, " .. self.name
end
print(person:greet())  -- "Hello, Alice Cooper"
```

### **배열 예제**

LUA에서 테이블을 사용하여 배열을 구현할 때, 일반적으로 정수 인덱스를 사용해 순차적으로 데이터를 저장합니다. 테이블의 인덱스는 1부터 시작하는 것이 일반적입니다 (대부분의 다른 프로그래밍 언어에서 배열 인덱스는 0부터 시작하는 것과 차이가 있습니다).

```lua
local fruits = {"apple", "banana", "cherry"}
print(fruits[1])  -- "apple"
print(fruits[2])  -- "banana"
print(fruits[3])  -- "cherry"
```

위 예제에서 **`fruits`** 테이블은 1부터 시작하는 인덱스를 사용하여 각 과일 이름을 저장합니다.

### **배열의 기능**

테이블을 사용하여 배열과 같은 기능을 제공할 수 있으며, LUA의 표준 라이브러리는 테이블을 조작하기 위한 여러 함수를 제공합니다.

### **배열 길이 구하기**

**`#`** 연산자를 사용하여 배열의 길이를 얻을 수 있습니다.

```lua
print(#fruits)  -- 3
```

### **요소 추가 및 삭제**

**`table.insert`** 함수를 사용하여 배열에 요소를 추가할 수 있습니다. 기본적으로 배열의 끝에 요소를 추가하지만, 특정 인덱스를 지정하여 요소를 삽입할 수도 있습니다.

```lua
table.insert(fruits, "mango")  -- 맨 끝에 추가
table.insert(fruits, 2, "orange")  -- 인덱스 2에 추가
```

요소를 삭제할 때는 **`table.remove`** 함수를 사용합니다.

```lua
table.remove(fruits, 1)  -- 첫 번째 요소 삭제
```

### **예제: 세트 구현**

**세트 :** 고유한 요소만을 저장하는 데이터 구조입니다. 테이블을 이용하여 구현할 수 있으며, 각 키에 대한 값으로 **`true`**를 설정하여 요소의 존재를 표시할 수 있습니다.

```lua
local set = {}
function addSet(set, key)
    set[key] = true
end

function checkSet(set, key)return set[key] or false
end

addSet(set, "apple")
print(checkSet(set, "apple"))  -- true
print(checkSet(set, "banana"))  -- false
```

### **테이블의 유연성**

LUA의 테이블은 그 구조 때문에 매우 유연합니다. 같은 테이블 내에 서로 다른 타입의 키와 값을 저장할 수 있으며, 이로 인해 배열, 세트, 맵 등 다양한 데이터 구조를 하나의 테이블로 표현할 수 있습니다. 예를 들어, 인덱스와 값의 쌍으로 구성된 배열과 함께, 이름과 값의 쌍으로 구성된 프로퍼티를 같은 테이블에 저장할 수 있습니다.

LUA에서 테이블과 함수는 매우 강력한 기능을 제공합니다. 특히 테이블은 LUA의 중심 데이터 구조로서 배열, 딕셔너리, 객체 등을 모두 표현할 수 있으며, 함수와 결합하여 객체 지향 프로그래밍을 모방할 수 있습니다. 테이블과 함수를 사용할 때, **`.`** 연산자와 **`:`** 연산자는 특별한 의미를 가지며, 이 두 연산자의 사용 방법과 주의점을 이해하는 것이 중요합니다.

### **테이블 예제**

```lua
local person = {
  name = "John",
  age = 30,
  greet = function(self)print("Hello, I am " + self.name)
  end
}
```

위 예제에서 **`person`**은 **`name`**, **`age`**, **`greet`** 세 개의 키를 가진 테이블입니다. **`greet`** 키는 함수를 값으로 가지고 있습니다.

### **`.` 연산자 vs `:` 연산자**

LUA에서는 테이블의 요소에 접근하거나 테이블의 함수를 호출할 때 **`.`** 또는 **`:`** 연산자를 사용할 수 있습니다. 이 두 연산자의 사용 방법과 의미는 다음과 같습니다.

### **`.` 연산자**

- 테이블의 요소에 접근할 때 사용합니다.
- 함수 호출 시 **`self`** 매개변수를 명시적으로 전달해야 합니다.

```lua
person.greet(person)  -- person을 명시적으로 전달
```

### **`:` 연산자**

- 메소드 호출에 사용됩니다.
- **`:`** 연산자를 사용하면 LUA는 자동으로 첫 번째 인자로 테이블 자신(**`self`**)을 전달합니다. 이는 객체 지향 프로그래밍에서 메소드 호출을 단순화합니다.

```lua
person:greet()  -- person은 자동으로 self로 전달됨
```

### **주의점**

- **명확성**: **`:`** 연산자를 사용할 때, 함수 내부에서 **`self`**가 자동으로 전달된다는 것을 항상 기억해야 합니다. 이를 간과하면 예상치 못한 동작이 발생할 수 있습니다.
- **일관성**: 일관된 코드 스타일을 유지하기 위해, 객체의 메소드를 호출할 때는 가능한 **`:`**를 사용하고, 단순 데이터 접근에는 **`.`**를 사용하는 것이 좋습니다.
- **함수 정의**: 메소드를 정의할 때 **`:`**를 사용하면, 자동으로 **`self`** 매개변수를 첫 번째 매개변수로 추가해야 합니다. **`:`**를 사용하지 않고 함수를 정의하면, **`self`**를 명시적으로 정의해야 할 때가 있습니다.

테이블과 함수를 이용한 **`.`**와 **`:`**의 사용은 LUA 프로그래밍에서 매우 중요한 요소입니다. 이러한 기능들을 정확히 이해하고 사용하면, 효과적인 코드 작성과 데이터 구조의 관리가 가능합니다. 프로그래머는 이 두 연산자의 차이점을 정확히 이해하고 적절히 사용하여 코드의 가독성과 유지 관리성을 향상시킬 수 있습니다.

## 메타테이블과 메타메소드

메타테이블을 사용하여 테이블 작업을 사용자 정의 할 수 있습니다. 예를 들어, 두 테이블을 '더하기' 연산으로 병합하는 것과 같은 행동을 정의할 수 있습니다. 기본적인 테이블 작업(예: 인덱싱, 할당)에 대한 동작을 변경하거나 확장할 수 있습니다.

### **메타메소드**

메타메소드는 특정 연산에 대응되는 함수입니다. 예를 들어, 두 테이블을 더하는 연산을 정의할 수 있습니다. 주요 메타메소드는 다음과 같습니다:

- **`__add`** : 덧셈
- **`__sub`** : 뺄셈
- **`__mul`** : 곱셈
- **`__div`** : 나눗셈
- **`__mod`** : 나머지 연산
- **`__unm`** : 단항 음수
- **`__concat`** : 연결 연산
- **`__eq`**, **`__lt`**, **`__le`** : 등가 및 비교 연산
- **`__index`**, **`__newindex`** : 인덱싱 동작
- **`__call`** : 함수 호출 흉내

### **메타테이블 설정 예제**

```lua
local t1 = {}
local meta = {
  __add = function (lhs, rhs)  -- 두 테이블의 덧셈 정의
    local sumTable = {}
    for k, v in pairs(lhs) do
      sumTable[k] = v + (rhs[k] or 0)
    end
    return sumTable
  end
}
setmetatable(t1, meta)
local t2 = {1, 2, 3}
local t3 = {4, 5, 6}
local t4 = t2 + t3
```

## **이터레이터와 테이블 순회**

이터레이터는 테이블이나 다른 컬렉션을 순회하기 위한 일반적인 방법입니다. LUA는 **`pairs`**와 **`ipairs`** 같은 내장 이터레이터를 제공합니다.

- **`pairs`**: 키-값 쌍을 순회합니다. 순서는 보장되지 않습니다.
- **`ipairs`**: 배열 부분만 연속적인 정수 인덱스로 순회합니다. 순서가 보장됩니다.

### **이터레이터 사용 예제**

```lua
luaCopy code
local t = {10, 20, 30, name = "Alice"}
for i, v in ipairs(t) do
  print(i, v)  -- 1 10, 2 20, 3 30 (name은 출력되지 않음)
end
for k, v in pairs(t) do
  print(k, v)  -- 모든 키-값 쌍 출력
end
```