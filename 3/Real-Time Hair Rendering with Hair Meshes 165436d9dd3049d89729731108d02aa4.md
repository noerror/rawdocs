# Real-Time Hair Rendering with Hair Meshes

[http://cemyuksel.com/research/hairmesh_rendering/](http://cemyuksel.com/research/hairmesh_rendering/)

- SIGGRAPH 2024

![100명의 캐릭터가 각각 10만 개의 가닥을 가진 고유한 헤어 모델을 가진 장면이 NVIDIA GTX 4090 GPU에서 (8배 MSAA 사용) 단 2ms 만에 래스터화된 모습. 이 장면의 모든 100개의 헤어 메쉬 모델은 1.7MB (모델당 13KB에서 21KB) 내에 들어간다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled.png)

100명의 캐릭터가 각각 10만 개의 가닥을 가진 고유한 헤어 모델을 가진 장면이 NVIDIA GTX 4090 GPU에서 (8배 MSAA 사용) 단 2ms 만에 래스터화된 모습. 이 장면의 모든 100개의 헤어 메쉬 모델은 1.7MB (모델당 13KB에서 21KB) 내에 들어간다.

## **1 INTRODUCTION**

머리카락은 가상 캐릭터의 중요한 시각적 요소로서, 그래픽스 분야에서 모델링, 애니메이션, 렌더링 등의 문맥에서 많은 관심을 받아왔다. 머리카락의 기하학적 복잡성은 주요한 도전 과제 중 하나인데, 이는 대부분의 사람이 약 10만 개의 머리카락을 가지고 있으며, 각 머리카락은 길이와 스타일에 따라 여러 제어점을 가진 곡선으로 표현되어야 하기 때문이다. 따라서, 전형적인 전체 머리카락 모델은 쉽게 백만 개 이상의 정점을 초과할 수 있어 실시간 렌더링에서 매우 비싸다.

이 논문에서는 머리카락 메쉬 구조를 사용하여 GPU에서 실시간으로 가닥 기반 머리카락 렌더링을 가속화하고 그 기하학적 복잡성을 관리하는 방법을 제시한다. 머리카락 메쉬는 두피 모델의 폴리곤 면을 외부로 돌출시켜 형성된 볼륨 구조로, 각 머리카락 가닥은 이러한 돌출부 내에서 생성되며 다양한 스타일링 작업을 통해 수정된다. 이를 통해 사용자는 개별 가닥의 기하학적 복잡성을 피하면서 전체 머리카락 모델의 형태를 정확하게 지정할 수 있다. 또한, 머리카락 메쉬는 사용자가 모델링 과정에서 외부 표면에 집중할 수 있도록 내부 정점을 자동으로 배치하여 일반적인 표면의 폴리곤 모델링과 유사하게 만든다.

이 논문에서는 실시간 렌더링 문제에 집중하여 GPU 셰이더에서 주어진 머리카락 메쉬와 스타일링 파라미터 세트를 사용하여 렌더링 동안 머리카락 가닥을 생성한다. 이를 통해 머리카락 데이터의 저장과 업데이트를 피하고, 저장 및 관리해야 하는 데이터의 양을 크게 줄일 수 있다. 이 과정에서 SIMD 병렬화에 맞춘 계산 작업 조직, 하드웨어 텍스처 유닛을 활용한 효율적인 보간 및 스플라인 생성, 임의의 변형에 적응하는 스타일링 변형을 적용하기 위한 일관된 로컬 좌표계 생성, 다양한 스타일의 머리카락을 생성할 수 있는 절차적 스타일링 작업, 그리고 자동으로 기하학을 줄일 수 있는 레벨 오브 디테일 기술을 도입하였다.

결과적으로, 이 프레임워크는 오늘날의 고급 GPU에서 실시간 프레임 속도로 수백 개의 고유한 가닥 기반 머리카락 모델을 렌더링할 수 있어 실시간 머리카락 렌더링의 기하학적 복잡성을 대폭 줄여준다.

## **2 BACKGROUND**

본 장에서는 실시간 머리카락 렌더링과 관련된 기존 연구와 머리카락 메쉬 구조에 대한 세부 사항을 다룬다.

**2.1 관련 연구**
머리카락의 기하학적 복잡성은 실시간 렌더링에 있어 항상 큰 도전 과제였다. 초기 방법들은 머리카락을 텍스처가 있는 표면으로 표현함으로써 이러한 복잡성을 피했으나, 이는 렌더링된 모델의 품질과 현실성을 심각하게 제한했다. GPU의 성능이 향상되면서 가닥 기반 머리카락 렌더링이 매력적인 대안으로 등장했지만, 비용이 많이 들었다. 가닥 기반 머리카락 렌더링은 많은 계산이 필요할 뿐만 아니라 각 가닥을 명시적으로 저장할 때 데이터 이동 비용도 발생한다.

데이터 이동 비용을 크게 줄이기 위한 한 가지 해결책은 렌더링 중에 즉석에서 머리카락 가닥을 생성하는 것이다. 이 접근 방식은 전체 머리카락 모델과 그 애니메이션을 정의하는 방식을 규정한다. 일반적으로 소수의 가이드 헤어를 사용하여 다른 머리카락 가닥의 모양을 결정하는 접근법이 사용된다. 그러나 추가 정보 없이 단순히 가이드를 보간하는 것만으로는 충분하지 않다. 최신 방법들은 모든 머리카락 가닥을 생성한 후 각 머리카락 정점의 이웃 가이드 헤어의 보간 가중치를 계산하고, 이 가중치를 사용하여 렌더링 중에 가이드 헤어를 보간하여 전체 해상도 머리카락 모델을 생성한다. 이 방법은 가닥 기반 헤어스타일의 효율적인 애니메이션을 가능하게 하지만, 여전히 보간 가중치를 저장해야 하므로 전체 머리카락 정점 위치를 저장하는 것만큼 공간을 차지할 수 있다.

![(a) 뿌리 레벨에서 두피 메쉬로부터 돌출된 4개의 번들을 가진 머리카락 메쉬의 2D 표현, (b) 머리카락 메쉬에서 생성된 머리카락 가닥들, (c) 절차적 스타일링 작업을 적용한 후의 가닥들 (출처: [Yuksel et al. 2009a]).](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%201.png)

(a) 뿌리 레벨에서 두피 메쉬로부터 돌출된 4개의 번들을 가진 머리카락 메쉬의 2D 표현, (b) 머리카락 메쉬에서 생성된 머리카락 가닥들, (c) 절차적 스타일링 작업을 적용한 후의 가닥들 (출처: [Yuksel et al. 2009a]).

우리의 해결책은 전체 해상도 머리카락 모델을 저장하는 비용을 피하면서 머리카락 메쉬를 사용하여 즉석에서 머리카락을 생성하는 것이다. 이와 유사한 접근 방식은 GPU에서 실 기반 천 모델의 섬유 수준 렌더링에도 사용된다. 레벨 오브 디테일(LOD) 방법은 실시간 렌더링에서 널리 사용되며, 실시간 머리카락 렌더링에도 쉽게 통합될 수 있다. 우리의 접근 방식은 기존 방법과 유사하지만, 디테일 수준 간의 전환 시 아티팩트를 방지하고 GPU 병렬 처리를 적절히 활용하기 위한 중요한 세부 사항을 포함한다.

최근에는 신경망을 사용한 머리카락 렌더링 방법이 유망한 새로운 방향으로 제시되고 있다. 이러한 방법들은 3D 머리카락 모델을 래스터화하는 데 있어 더 느리고 더 많은 메모리를 소비하지만, 현실적인 머리카락 외형을 생성하는 데 장점이 있다. 우리의 방법은 가닥 기반 머리카락 래스터화에 의존하는 미래의 신경망 머리카락 렌더링 파이프라인에서도 활용될 수 있다.

**2.2 머리카락 메쉬 구조**
머리카락 메쉬 구조는 두피 모델의 폴리곤 얼굴을 외부로 돌출시켜 형성된 층들로 구성된다. 두피 메쉬의 각 얼굴은 하나의 번들에 해당하며, 각 머리카락 가닥의 뿌리 위치는 두피 모델의 얼굴 위의 한 점에 해당한다. 이 점은 머리카락 가닥 곡선의 첫 번째 제어점이 된다. 다른 제어점들은 동일한 두피 얼굴에서 연속적으로 돌출된 층들에서 같은 점을 사용하여 형성된다.

머리카락 메쉬에서 생성된 개별 머리카락 가닥은 메쉬 볼륨 내에서 균일한 흐름을 형성하며, 이웃한 가닥들 사이에 변형이 없다. 이러한 변형은 일반적으로 랜덤한 변형이나 절차적 함수들을 통해 도입된다. 머리카락 가닥은 처음에 머리카락 메쉬에서 생성된 곡선을 따라 배치되며, 이후 절차적 스타일링 작업을 통해 수정된다.

이 논문에서 설명하는 즉석 머리카락 생성 방법은 GPU 코어의 계산 과정에 맞춰 세부 사항이 다르며, 텍스처 필터링 유닛을 사용하여 일부 계산을 오프로드한다.

## **3 RENDERING WITH HAIR MESHES**

본 장에서는 머리카락 메쉬를 사용하여 실시간으로 가닥 기반 머리카락을 렌더링하는 방법을 설명한다. 이 방법은 GPU에서 텍스처 필터링 하드웨어를 활용하여 머리카락 곡선을 생성하고, 이를 통해 렌더링 성능을 크게 향상시킨다.

![예시 머리카락 메쉬 모델과 그 머리카락 메쉬 텍스처: (a) 머리카락 메쉬, (b) 3D 머리카락 메쉬 텍스처, (c) 이 머리카락 메쉬 텍스처의 2D 뿌리 슬라이스, (d) t 방향으로의 첫 번째 2D 슬라이스와 그 슬라이스의 큐빅 베지어 제어점, (e) 각 큐빅 베지어 구간을 두 개의 쿼드 베지어 곡선으로 나누어 생성된 쿼드 베지어 제어점을 가진 동일한 슬라이스. 이 예시에서, p0, b+0, b-5, p5의 제어점을 가진 큐빅 베지어 곡선이 p0, q+0, q0,5로 첫 번째 쿼드 베지어 곡선으로 변환되고, q0,5, q-5, p5로 두 번째 쿼드 베지어 곡선으로 변환된다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%202.png)

예시 머리카락 메쉬 모델과 그 머리카락 메쉬 텍스처: (a) 머리카락 메쉬, (b) 3D 머리카락 메쉬 텍스처, (c) 이 머리카락 메쉬 텍스처의 2D 뿌리 슬라이스, (d) t 방향으로의 첫 번째 2D 슬라이스와 그 슬라이스의 큐빅 베지어 제어점, (e) 각 큐빅 베지어 구간을 두 개의 쿼드 베지어 곡선으로 나누어 생성된 쿼드 베지어 제어점을 가진 동일한 슬라이스. 이 예시에서, p0, b+0, b-5, p5의 제어점을 가진 큐빅 베지어 곡선이 p0, q+0, q0,5로 첫 번째 쿼드 베지어 곡선으로 변환되고, q0,5, q-5, p5로 두 번째 쿼드 베지어 곡선으로 변환된다.

**3.1 머리카락 메쉬 텍스처**
머리카락 메쉬의 정점 위치를 저장하기 위해 특별한 3D 텍스처를 사용한다. 이 텍스처는 GPU의 텍스처 필터링 하드웨어를 활용하여 머리카락 가닥 생성 중 필요한 보간 계산을 수행한다. 텍스처의 첫 번째 2D 슬라이스는 뿌리 레이어를 나타내며, 각 텍셀은 두피 메쉬의 정점 위치를 저장한다. 나머지 레이어 슬라이스는 연속적인 층의 정점 위치를 저장하며, 이로써 3D 텍스처 내에서 머리카락 곡선을 계산할 수 있다.

**3.2 GPU에서의 머리카락 생성**
렌더링 동안 GPU에서 머리카락 가닥을 생성한다. 이 가닥들은 렌더 패스마다 재생성되며, 저장되지 않는다. 이를 통해 머리카락 데이터를 저장할 필요가 없어 수백 메가바이트의 저장 공간을 절약할 수 있다. 머리카락 생성 작업은 GPU의 메쉬 셰이더를 사용하여 병렬로 수행되며, 각 메쉬 셰이더 스레드는 머리카락 가닥을 생성하는 데 필요한 여러 정점을 계산한다.

**3.3 머리카락 뿌리 배치**
머리카락 가닥은 머리카락 메쉬 내의 뿌리 위치에 의해 정의된다. 우리는 블루 노이즈 분포를 사용하여 2D 샘플 위치를 미리 계산하고, 이를 사용해 자연스러운 뿌리 배치를 구현한다. 각 두피 얼굴 유형에 따라 다른 샘플 세트를 사용하여 뿌리 위치를 결정한다.

**3.4 스타일링 좌표**
머리카락 스타일링은 각 가닥의 형태를 변경하고, 이웃 가닥 간의 기하학적 변형을 지정하는 중요한 과정이다. 스타일링 좌표는 텍스처 공간에 임베딩되어 있으며, 머리카락 메쉬가 변형될 때도 일관성을 유지하도록 설계되었다. 이 스타일링 좌표는 3D 텍스처 공간의 좌표로 정의되며, 이를 통해 머리카락 가닥의 위치를 계산한다.

![ (a) 유한 차분을 사용한 스타일링 좌표 계산은 스타일링 불연속성을 초래할 수 있으며, 이 예시에서는 가운데의 수직 솔기로 보인다, (b) 우리의 솔루션은 이러한 솔기를 방지한다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%203.png)

 (a) 유한 차분을 사용한 스타일링 좌표 계산은 스타일링 불연속성을 초래할 수 있으며, 이 예시에서는 가운데의 수직 솔기로 보인다, (b) 우리의 솔루션은 이러한 솔기를 방지한다.

![동일한 머리카락 메쉬 레이어의 정점(빨간색으로 강조됨)을 둘러싼 네 개의 삼각형. 각 삼각형은 정점과 정점에서 나오는 두 개의 엣지를 포함하고 있으며, 파란색으로 강조되었다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%204.png)

동일한 머리카락 메쉬 레이어의 정점(빨간색으로 강조됨)을 둘러싼 네 개의 삼각형. 각 삼각형은 정점과 정점에서 나오는 두 개의 엣지를 포함하고 있으며, 파란색으로 강조되었다.

**3.5 머리카락 탄젠트**
셰이딩을 위해 머리카락의 탄젠트 방향이 필요하다. 우리는 각 정점의 이전 정점과 다음 정점 간의 벡터를 탄젠트 방향으로 설정하여 탄젠트를 계산한다. 끝 정점의 경우, 마지막 머리카락 구간의 각도 분리를 사용하여 일관된 탄젠트를 설정한다.

**3.6 레벨 오브 디테일**
즉석 머리카락 생성은 머리카락 가닥의 수와 각 가닥의 정점 수를 동적으로 줄여 레벨 오브 디테일(LOD)을 구현할 수 있다. 우리는 카메라와의 최소 거리와 사용자 정의 스케일링 매개변수를 기반으로 디테일 레벨을 결정하며, 디테일 전환이 부드럽게 이루어지도록 설계하였다. 머리카락 가닥의 수를 줄일 때는 가닥의 두께를 증가시켜 보상하고, 정점 수를 줄일 때는 전환 윈도우 내에서 지오메트리적 전환을 사용하여 일관된 렌더링을 유지한다.

![ 동일한 스타일링 함수를 사용하여 생성된 다른 수의 정점을 가진 가닥들. 9개의 정점과 8개의 정점 사이의 차이가 매우 클 수 있으며, 5개의 정점과의 차이는 더욱 크다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%205.png)

 동일한 스타일링 함수를 사용하여 생성된 다른 수의 정점을 가진 가닥들. 9개의 정점과 8개의 정점 사이의 차이가 매우 클 수 있으며, 5개의 정점과의 차이는 더욱 크다.

결과적으로, 본 장에서는 머리카락 메쉬를 사용하여 GPU에서 실시간으로 고해상도의 머리카락 가닥을 효율적으로 렌더링하는 방법을 상세히 설명한다. 이 방법은 현재의 고급 GPU에서 수백 개의 독특한 머리카락 모델을 실시간으로 렌더링할 수 있도록 하며, 머리카락 렌더링의 기하학적 복잡성을 크게 줄여준다.

## **4 RESULTS**

본 장에서는 제안된 방법의 성능을 NVIDIA GTX 4090 GPU에서 테스트한 결과를 제시하고, 기존의 가닥 기반 머리카락 렌더링 방법과 비교한다.

100명의 캐릭터가 각각 10만 개의 가닥을 가진 고유한 헤어스타일을 가진 장면에서, 우리의 방법은 레벨 오브 디테일(LOD) 기법을 사용하여 8배의 멀티 샘플 안티앨리어싱(MSAA)로 2밀리초 내에 머리카락을 생성하고 래스터화할 수 있었다. LOD를 사용하지 않으면 동일한 장면에서 47밀리초가 소요된다. 이는 LOD가 대규모 장면에서 중요한 역할을 한다는 것을 보여준다.

최신의 가이드 헤어 스키닝(LHS) 방법과 직접 비교하기 위해, 동일한 머리카락 모델을 생성하고 가이드 헤어를 추출하여 LHS 가중치를 미리 계산한 후 LHS로 렌더링하였다. 그 결과, LHS는 18밀리초가 소요되었으며, 이는 MSAA 사용 여부와 관계없이 동일하였다. 반면, 우리의 방법은 동일한 모델을 즉석에서 생성하고 1.8밀리초 내에 래스터화할 수 있어 10배의 성능 향상을 보여주었다. 8배 MSAA를 사용할 경우, 시간은 3.3밀리초로 증가하였다. 이는 하드웨어 래스터라이저 대신 최적화된 소프트웨어 래스터라이저를 사용하면 성능이 더욱 향상될 수 있음을 시사한다.

LHS와 우리의 방법 간의 성능 차이는 두 방법이 사용하는 데이터 양에서 기인한다. LHS는 340MB의 메모리를 필요로 하지만, 우리의 텍스처는 39KB만 차지한다. 비교에서 LOD를 사용하지 않았다는 점을 감안하면, 우리의 방법이 메모리 사용 면에서 훨씬 효율적임을 알 수 있다.

다양한 거리에서 카메라와의 거리 변화에 따른 LOD 사용 유무를 비교한 결과, 우리의 LOD 방법은 모델 복잡성을 점진적으로 줄이면서도 유사한 이미지를 생성할 수 있었다.

또한, 200개의 유타 찻주전자에 각각 5만 개의 가닥을 가진 머리카락 메쉬와 헤어스타일을 적용한 장면에서, 우리의 방법은 8배 MSAA로 1.8밀리초, MSAA 없이 1.1밀리초 내에 모든 머리카락을 래스터화하였다. LOD를 사용하지 않으면 머리카락 모델은 660억 개의 삼각형으로 구성되어 150밀리초가 소요되었다. 이 장면의 모든 머리카락 가닥은 찻주전자당 평균 11KB에서 27KB의 텍스처로 표현되며, 총 3.2MB의 메모리만 차지한다.

다양한 스타일링 파라미터를 사용하여 생성된 여러 헤어스타일을 보여준 결과, 상대적으로 낮은 해상도의 머리카락 모델로도 복잡한 가닥 기반 헤어스타일을 생성할 수 있음을 확인하였다. 이러한 스타일링 함수는 다양한 절차적 스타일링 함수로 쉽게 통합될 수 있다.

결론적으로, 우리의 방법은 머리카락 메쉬를 사용하여 실시간으로 가닥 기반 머리카락을 렌더링할 수 있는 방법을 제시하며, 이를 통해 고성능 GPU뿐만 아니라 저성능 장치에서도 효율적인 렌더링이 가능함을 입증하였다.

![총 30만 개의 머리카락 가닥을 가진 세 개의 헤어 모델이 1.8ms 내에 LOD 없이 MSAA 없이, 3.3ms 내에 8배 MSAA와 함께 생성 및 래스터화된 모습. 동일한 이미지를 LHS를 사용해 총 3천 개의 가이드 헤어로 렌더링하는 데 18ms가 소요된다 (MSAA 사용 여부와 관계없이). 이 세 개의 머리카락 메쉬를 위한 우리의 5개 텍스처는 총 39KB를 차지하며, LHS의 경우 거의 10억 개의 정점을 가진 머리카락 데이터에 대해 340MB를 사용한다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%206.png)

총 30만 개의 머리카락 가닥을 가진 세 개의 헤어 모델이 1.8ms 내에 LOD 없이 MSAA 없이, 3.3ms 내에 8배 MSAA와 함께 생성 및 래스터화된 모습. 동일한 이미지를 LHS를 사용해 총 3천 개의 가이드 헤어로 렌더링하는 데 18ms가 소요된다 (MSAA 사용 여부와 관계없이). 이 세 개의 머리카락 메쉬를 위한 우리의 5개 텍스처는 총 39KB를 차지하며, LHS의 경우 거의 10억 개의 정점을 가진 머리카락 데이터에 대해 340MB를 사용한다.

![중간 및 먼 거리에서 렌더링된 이미지와 해당 모델. 우리의 LOD가 생성된 모델의 기하학적 복잡성을 크게 단순화하면서도 LOD 없이 모델을 렌더링한 것과 유사한 렌더링 이미지를 생성할 수 있음을 보여준다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%207.png)

중간 및 먼 거리에서 렌더링된 이미지와 해당 모델. 우리의 LOD가 생성된 모델의 기하학적 복잡성을 크게 단순화하면서도 LOD 없이 모델을 렌더링한 것과 유사한 렌더링 이미지를 생성할 수 있음을 보여준다.

## **5 CONCLUSION**

본 장에서는 머리카락 메쉬를 사용하여 실시간으로 가닥 기반 머리카락을 렌더링할 수 있는 방법을 제시하였다. 우리의 접근 방식은 메쉬 셰이더에서 작업 부하를 신중하게 분배하고, 텍스처 필터링 유닛을 활용하여 일부 계산을 오프로드하며, 레벨 오브 디테일(LOD)을 통해 성능을 최적화한다. 또한, 머리카락 메쉬가 변형될 때 스타일링 변형이 일관성을 유지할 수 있도록 연속적인 스타일링 좌표를 부착하는 방법을 설명하였다.

이 방법은 고성능 GPU에서 수백 개의 캐릭터에 대한 가닥 기반 머리카락을 실시간 프레임 속도로 렌더링할 수 있으며, 저성능 장치에서도 가닥 기반 머리카락 렌더링을 훨씬 더 저렴하게 만들 수 있다.

그러나 우리의 접근 방식은 머리카락 모델이 머리카락 메쉬와 일련의 스타일링 파라미터로 정의되어야 한다는 제약이 있다. 임의의 가닥 기반 머리카락 모델을 자동으로 변환하는 것은 불가능하다. 이는 향후 연구에서 해결할 수 있는 중요한 과제로 남아 있다.

![고유한 헤어 모델을 가진 200개의 유타 찻주전자 모델. 각 헤어 모델은 다른 스타일링 파라미터 세트를 가진 5만 개의 머리카락 가닥을 포함한다. 이 장면의 모든 머리카락은 8배 MSAA로 총 1.8ms 내에 래스터화된다. 이 장면의 200개의 개별 헤어 메쉬 모델을 위한 우리의 5개 텍스처는 총 3.2MB (찻주전자당 평균 17KB)에 들어간다.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%208.png)

고유한 헤어 모델을 가진 200개의 유타 찻주전자 모델. 각 헤어 모델은 다른 스타일링 파라미터 세트를 가진 5만 개의 머리카락 가닥을 포함한다. 이 장면의 모든 머리카락은 8배 MSAA로 총 1.8ms 내에 래스터화된다. 이 장면의 200개의 개별 헤어 메쉬 모델을 위한 우리의 5개 텍스처는 총 3.2MB (찻주전자당 평균 17KB)에 들어간다.

![다양한 헤어 메쉬와 그로부터 생성된 헤어스타일들이 LOD 없이 우리의 방법을 사용하여 8배 MSAA와 함께 렌더링된 모습. 모든 헤어 모델은 10만 개의 머리카락 가닥을 가지고 있으며, 래스터화하는 데 1ms가 소요된다 (e는 1.8ms 소요). 각 모델을 나타내는 데 사용하는 5개의 텍스처의 해상도와 저장 비용은 다음과 같다: (a-b) 185개 정점/13KB, (c) 477개 정점/34KB, (d) 7892개 정점/563KB, (e) 1316개 정점/94KB, (f) 3236개 정점/231KB.](Real-Time%20Hair%20Rendering%20with%20Hair%20Meshes%20165436d9dd3049d89729731108d02aa4/Untitled%209.png)

다양한 헤어 메쉬와 그로부터 생성된 헤어스타일들이 LOD 없이 우리의 방법을 사용하여 8배 MSAA와 함께 렌더링된 모습. 모든 헤어 모델은 10만 개의 머리카락 가닥을 가지고 있으며, 래스터화하는 데 1ms가 소요된다 (e는 1.8ms 소요). 각 모델을 나타내는 데 사용하는 5개의 텍스처의 해상도와 저장 비용은 다음과 같다: (a-b) 185개 정점/13KB, (c) 477개 정점/34KB, (d) 7892개 정점/563KB, (e) 1316개 정점/94KB, (f) 3236개 정점/231KB.