# Performance Comparison of Meshlet Generation Strategies

[https://jcgt.org/published/0012/02/01/](https://jcgt.org/published/0012/02/01/)

![스탠포드 토끼의 삼각형을 메시렛으로 구성하는 다양한 방법. 각 색상의 패치는 메시렛입니다. 왼쪽 위부터 오른쪽 아래까지: 최적화된 인덱스 버퍼를 사용하는 NVIDIA [Kubisch 2018b], k-medoids [Kaufman and Rousseeuw 1990], greedy(우리 방식), 바운딩 스피어(우리 방식), Kapoulkine [2017]. 자세한 방법은 섹션 3에서 설명합니다. 각 이미지는 삼각형당 나노초 단위의 렌더링 시간을 보여줍니다. 이 시간은 트라이앵글 수에 따른 6개 메시의 렌더링 시간에 맞는 선형 회귀를 기반으로 합니다. K-메도이드는 데이터 포인트가 너무 적기 때문에 시간을 생략합니다.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled.png)

스탠포드 토끼의 삼각형을 메시렛으로 구성하는 다양한 방법. 각 색상의 패치는 메시렛입니다. 왼쪽 위부터 오른쪽 아래까지: 최적화된 인덱스 버퍼를 사용하는 NVIDIA [Kubisch 2018b], k-medoids [Kaufman and Rousseeuw 1990], greedy(우리 방식), 바운딩 스피어(우리 방식), Kapoulkine [2017]. 자세한 방법은 섹션 3에서 설명합니다. 각 이미지는 삼각형당 나노초 단위의 렌더링 시간을 보여줍니다. 이 시간은 트라이앵글 수에 따른 6개 메시의 렌더링 시간에 맞는 선형 회귀를 기반으로 합니다. K-메도이드는 데이터 포인트가 너무 적기 때문에 시간을 생략합니다.

### 1. Introduction

고효율 렌더링 기술인 래스터화는 확장 현실(xR) 애플리케이션에서 매우 중요합니다. 그 중요성은 속도와 높은 프레임 속도를 유지하는 능력에서 비롯되며, 이는 멀미를 방지하고 xR의 몰입감을 유지하는 데 필수적입니다. 이 프로세스에는 매 프레임마다 메시의 각 트라이앵글을 처리하는 과정이 포함되며, 메시가 클 경우 리소스 집약적이 될 수 있습니다. 이때 '메시렛'이라는 개념이 등장합니다.

메시 셰이딩 및 메시렛

대형 트라이앵글 메시를 효과적으로 관리하기 위해 래스터화 파이프라인은 쿠비쉬가 도입한 메시렛을 포함하도록 수정되었습니다. 메시렛은 삼각형의 클러스터로, 더 거친 수준에서 더 효율적으로 처리할 수 있어 그래픽 처리 장치(GPU)의 작업 부하를 줄여줍니다. 이러한 혁신은 기술적인 발전일 뿐만 아니라 특히 렌더링 성능을 극대화하기 위해 이러한 메시를 최적으로 구성하는 것과 관련하여 새로운 도전과 질문을 제기하고 있습니다.

GPU의 진화와 트라이앵글 메시 최적화

GPU는 크게 발전하여 병렬 연산을 위한 강력한 도구가 되었습니다. 이러한 발전은 데이터 전송 병목 현상을 줄이기 위해 트라이앵글 스트립 및 메시 버퍼와 같은 트라이앵글 메시 처리를 최적화하는 다양한 방법으로 이어졌습니다. 이러한 방법은 데이터 풋프린트를 최소화하고 GPU의 캐싱 메커니즘 사용을 극대화하는 데 중점을 둡니다. 또한 이 백서에서는 GPU 기반 렌더링에서 효율적인 데이터 구조와 알고리즘의 중요성을 강조하는 Arkin 외, Evans 외, Hoppe의 접근 방식을 비롯한 이 분야의 중요한 연구를 참조하고 있습니다.

메시 셰이딩 파이프라인: 진화하는 단계

버텍스 셰이딩 파이프라인의 진화 버전인 메시 셰이딩 파이프라인은 GPU가 메시 데이터를 처리하는 방식에 큰 변화를 가져왔습니다. 이 파이프라인은 개별 트라이앵글 대신 메시렛을 처리하므로 메시 일괄 처리에 대해 더 많은 정보를 바탕으로 의사 결정을 내릴 수 있습니다. 또한 버텍스 재사용을 위해 공유 메모리를 활용하므로 포스트 트랜스폼 및 조명 캐시가 필요하지 않습니다. 이 파이프라인은 복잡한 지오메트리 데이터 세트를 보다 효율적으로 렌더링할 수 있도록 하는 GPU 아키텍처의 중요한 단계로 간주됩니다.

업계에서의 의미와 활용

다양한 산업, 특히 게임 분야에서 메시 셰이더를 채택하는 것은 메시 셰이더의 실질적인 중요성을 나타냅니다. 메시 셰이딩을 최적화하기 위한 도구와 기법이 점점 더 많이 연구되고 있으며, Jensen 외, Unterguggenberger 외의 연구에서도 알 수 있듯이 메시 셰이딩을 최적화하기 위한 도구와 기법이 점점 더 많이 연구되고 있습니다. 이 논문은 더 나은 실시간 렌더링 성능을 위해 메시 생성 전략에 대한 지속적인 탐구와 최적화의 필요성을 강조합니다.

요약하자면, 이 백서에서는 GPU 아키텍처와 렌더링 기술의 진화를 살펴보고, xR 및 기타 수요가 많은 애플리케이션에서 효율적인 렌더링을 위한 메시 셰이딩 및 메시렛으로의 전환에 중점을 둡니다. 또한 실시간 그래픽 렌더링의 한계를 계속 확장하기 위해 이 분야에 대한 지속적인 연구 개발이 필요하다는 점을 강조합니다.

### 2. Meshlets Descriptors

![GPU가 메클릿을 처리할 때 사용하는 세 가지 버퍼: 로컬 인덱스 버퍼, 글로벌 인덱스 버퍼, 버텍스 버퍼. 메클릿 설명자는 이러한 버퍼에 오프셋을 가지고 있습니다. 글로벌 인덱스는 사용되는 모든 메클릿에 (재)나타납니다.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%201.png)

GPU가 메클릿을 처리할 때 사용하는 세 가지 버퍼: 로컬 인덱스 버퍼, 글로벌 인덱스 버퍼, 버텍스 버퍼. 메클릿 설명자는 이러한 버퍼에 오프셋을 가지고 있습니다. 글로벌 인덱스는 사용되는 모든 메클릿에 (재)나타납니다.

버퍼 설정 이해

메시 셰이딩 파이프라인에서는 로컬 인덱스 버퍼, 글로벌 인덱스 버퍼, 버텍스 버퍼 등 세 가지 유형의 버퍼가 사용됩니다. 로컬 인덱스 버퍼는 각 메시에 대해 세그먼트화되며, 각 섹션의 인덱스는 0부터 시작됩니다. 글로벌 인덱스 버퍼는 비슷한 기능을 하지만 인덱스 중복을 줄이는 데 중점을 둡니다. 버텍스 버퍼는 기존 버텍스 셰이딩 파이프라인에서 사용되는 버퍼와 일관성을 유지합니다. 각 메시클릿에는 GPU의 멀티프로세서에 필수적인 메타데이터를 제공하는 작은 디스크립터가 함께 제공됩니다.

메시릿 디스크립터: 구조와 기능

NVIDIA에서 권장하는 메시클릿 디스크립터는 128비트의 컴팩트한 구조로, GPU 연산에 최적화되어 있습니다. 이 디스크립터에는 글로벌 및 로컬 인덱스 버퍼에 대한 오프셋, 메시클릿의 프리미티브 및 버텍스 수와 같은 중요한 정보가 포함되어 있습니다. 또한 프로그래머가 결정한 바운딩 박스, 평균 노멀 또는 기타 관련 데이터를 포함할 수도 있습니다.

설명자의 변형

이 백서에서는 각각 최대 128비트를 사용하고 바운딩 박스와 프리미티브 및 정점에 대한 세부 정보를 통합하는 네 가지 다른 메릿 설명자에 대해 설명합니다. 주목할 만한 특징은 노멀 콘을 24비트 이내로 표현한다는 점입니다. 이러한 디스크립터 간의 차이점은 주로 글로벌 및 로컬 인덱스 버퍼의 오프셋을 처리하는 방식에 있습니다.

NVIDIA 디스크립터 A: 제한된 오프셋 인덱싱을 제공하며, 작은 메시에는 적합하지만 큰 메시의 경우 여러 번의 드로 콜이 필요합니다.
NVIDIA 디스크립터 B: 한 번의 드로 콜로 더 큰 메시를 허용하지만 글로벌 및 로컬 인덱스 버퍼에 대한 정렬된 오프셋이 필요합니다.
분할 디스크립터: 작업 디스크립터와 메시 디스크립터를 분리하여 버퍼 간 정렬이 필요 없고 각 메시마다 256비트를 사용합니다.
모놀리식 설명자: 버텍스 버퍼로 직접 오프셋하여 글로벌 인덱스 버퍼를 피하므로 버텍스 중복이 발생할 수 있지만 전체 구조가 단순화됩니다.
하드웨어 제한 및 권장 사항

![로컬 인덱스 버퍼와 버텍스 버퍼, 두 개의 버퍼만 사용하여 메시클릿을 처리할 때 GPU에서 사용하는 버퍼 설정의 모놀리식 버전. 모놀리식 메시렛 설명자에는 여기에 오프셋이 있습니다. 버텍스는 사용되는 모든 메시클릿에 (재)나타납니다.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%202.png)

로컬 인덱스 버퍼와 버텍스 버퍼, 두 개의 버퍼만 사용하여 메시클릿을 처리할 때 GPU에서 사용하는 버퍼 설정의 모놀리식 버전. 모놀리식 메시렛 설명자에는 여기에 오프셋이 있습니다. 버텍스는 사용되는 모든 메시클릿에 (재)나타납니다.

메시클릿 용량은 GPU 하드웨어에 의해 제한되며, NVIDIA의 RTX 2000 시리즈는 메시클릿당 최대 256개의 버텍스와 프리미티브를 허용합니다. NVIDIA는 각 메시클릿에 64개의 버텍스와 126개의 프리미티브를 사용하여 성능과 효율성의 균형을 맞출 것을 권장합니다.

성능 비교를 위한 디스크립터 선택

저자들은 성능 비교를 위해 한 번의 드로 콜로 대규모 메시를 쉽게 처리할 수 있는 NVIDIA 디스크립터 B를 선택했습니다. 이 선택은 다양한 메시클릿 클러스터링 방법을 비교하여 어떤 방법이 최고의 렌더링 성능을 제공하는지 확인하기 위해 이루어졌습니다.

이 백서의 이 섹션에서는 메시 셰이딩 파이프라인의 버퍼 설정과 메시릿 디스크립터의 구조에 대해 자세히 설명합니다. 또한 다양한 디스크립터의 종류와 렌더링 성능에 미치는 영향을 강조하면서 메시 크기와 GPU 성능에 따라 적합한 디스크립터를 선택하는 것이 중요하다는 점을 강조합니다.

### 3. Meshlet Clustering Methods

다양한 클러스터링 방법 개요

이 섹션에서는 메시를 메시렛으로 클러스터링하는 다양한 방법에 대해 설명하며, 각 방법마다 고유한 접근 방식과 렌더링 성능에 미치는 영향에 대해 설명합니다.

![인덱스 버퍼를 최적화하지 않은 경우(왼쪽)와 팁시파이 알고리즘을 사용하여 인덱스 버퍼를 최적화한 후(오른쪽)의 NVIDIA 생성 메시클릿 시각화.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%203.png)

인덱스 버퍼를 최적화하지 않은 경우(왼쪽)와 팁시파이 알고리즘을 사용하여 인덱스 버퍼를 최적화한 후(오른쪽)의 NVIDIA 생성 메시클릿 시각화.

NVIDIA 방법: NVIDIA를 대신하여 Kubisch가 개발한 이 방법은 메시가 가득 찰 때까지 순차적으로 기본 요소와 정점을 메시렛에 추가한 다음 새 메시렛을 생성합니다. 이 방법은 글로벌 버텍스 인덱스의 중복을 제거하고 로컬 인덱스를 재사용하여 공간을 최적화합니다. 이 방법은 인덱스 버퍼의 원래 구조에 따라 크게 달라집니다.

카풀카인의 방법: 메쉬 옵티마이저 라이브러리의 일부인 이 메서드는 삼각형과 정점 인접성을 기반으로 각 삼각형의 중심과 법선을 계산합니다. 이 방법은 kd 트리를 사용하여 메쉬렛 형성을 시작하고 정점 재사용과 면적 증가에 따라 삼각형을 평가합니다. 이 알고리즘은 가중치를 조정하여 메시렛을 형성하는 동안 특정 측면의 우선순위를 정할 수 있습니다.

그리디 알고리즘: 사용자 정의로 개발된 이 알고리즘은 정점 목록에서 메시클릿을 성장시켜 메시클릿의 용량에 도달할 때까지 클러스터를 확장합니다. 이 알고리즘은 이미 메시렛에 있는 모든 정점이 있는 삼각형을 우선적으로 추가하고 경계 정점부터 새 메시렛을 시작합니다. 정점 목록은 성능 향상을 위해 휴리스틱을 기반으로 정렬됩니다.

바운딩 구체 전략: 그리디 방법과 유사하게 이 전략은 시작 정점을 중심으로 바운딩 구를 성장시킵니다. 특정 알고리즘을 사용하여 바운딩 구체 반경을 최소화하는 삼각형을 추가하는 동시에 버텍스 재사용과 고립된 삼각형을 고려합니다.

K-메도이드 방법: 비지도 학습의 기법을 응용한 이 방법은 파티션 내의 유사성을 최소화하여 균형 잡힌 클러스터를 생성합니다. 이 방법은 클러스터 내의 대표 지점인 메도이드를 사용하여 메시렛에 맞는 클러스터를 형성합니다. 이 방법은 복잡하고 처리 시간이 더 오래 걸립니다.

비교 분석 및 시사점

각 방법은 복잡성과 처리 시간이 다릅니다. NVIDIA의 접근 방식은 인덱스 버퍼를 직접 활용하는 간단한 방식입니다. 약간 더 복잡한 욕심 알고리즘은 버텍스와 삼각형 인접성을 기반으로 정렬된 목록을 사용합니다. 카풀카인의 방법과 바운딩 스피어 전략은 추가 구조와 점수 함수로 복잡성을 더합니다. K-메타이드는 가장 복잡하기 때문에 실제 적용을 위해서는 반복적인 과정과 최적화가 필요합니다.

이러한 방법의 처리 시간은 크게 다르며, K-메도이드가 복잡성으로 인해 가장 오래 걸립니다. 그러나 각 방법의 효과와 효율성은 특정 메쉬와 원하는 결과에 따라 달라지므로, 당면한 작업에 적합한 방법을 선택하는 것이 중요합니다.

이 섹션에서는 메쉬를 메쉬렛으로 구성하는 5가지 방법을 살펴보고 각 방법의 고유한 접근 방식, 복잡성 및 처리 시간에 미치는 영향을 강조합니다. 이러한 방법은 각각 렌더링의 다양한 시나리오와 성능 요구 사항에 적합한 메시 클러스터링 최적화를 위한 다양한 옵션을 제공합니다.

### 4. Experimental Setup

목표 및 접근 방식

이 실험 설정의 주요 목표는 5개의 서로 다른 메시 클러스터링 알고리즘을 비교하여 가장 효율적인 알고리즘을 식별하는 것이었습니다. 연구원들은 다양한 하드웨어 구성에 적용할 수 있는 메시클릿 생성에 대한 광범위한 원칙을 추출하는 것을 목표로 했습니다.

![실험에 사용된 6개의 메시와 각 메시의 정점(V) 및 삼각형(T) 수.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%204.png)

실험에 사용된 6개의 메시와 각 메시의 정점(V) 및 삼각형(T) 수.

편향되지 않은 테스트 보장

공정하고 편향되지 않은 비교를 위해 연구원들은 픽셀당 4개의 샘플로 설정된 다중 샘플 안티앨리어싱(MSAA)이 포함된 Vulkan 시각화 엔진(버전 1.2.176.1)을 활용했습니다. 테스트는 각 프레임마다 공간에서 무작위로 생성된 시점에서 오브젝트를 시각화하는 방식으로 진행되었는데, 이는 오버드로(덮힌 표면의 과도한 렌더링) 효과를 평균화하기 위해 고안된 기법입니다. 시점의 순서는 고정된 랜덤 시드를 사용하여 모든 알고리즘에서 일관성을 유지했습니다. 이 과정은 100,000프레임 동안 반복되었지만 첫 번째 프레임은 GPU로의 초기 데이터 전송 시간을 제외하기 위해 버려졌습니다.

하드웨어 및 소프트웨어 사양

실험은 인텔 코어 i9-9900k 프로세서, 64GB DDR4-2666 RAM, 11GB GDDR6 RAM이 장착된 엔비디아 지포스 RTX 2080 Ti 터보 OC 그래픽 카드가 장착된 고성능 데스크톱 컴퓨터에서 진행되었습니다. 렌더링 해상도는 1280x720픽셀로 설정했습니다. 메시 처리를 위해 Vulkan의 메시 셰이더에 맞게 특별히 조정된 NVIDIA GitHub 리포지토리의 셰이더 코드를 사용했습니다.

방법론 및 사용된 모델

실험에서는 메시 셰이더에서 트라이앵글 컬링을 비활성화하고, 작업 셰이더에서 프러스텀 및 백페이스 컬링을 수행했습니다. 각 알고리즘의 성능은 프레임당 평균 렌더링 시간으로 측정했으며, 메시렛과 관련된 추가 지표도 분석했습니다. 테스트에는 각각 다른 버텍스와 트라이앵글 수를 가진 6가지 3D 모델이 사용되었습니다. 이 모델에는 스탠포드 3D 스캐닝 리포지토리의 스탠포드 버니, 해피 붓다, 아시안 드래곤, 디지털로 재구성한 바다표범 두개골, 토폴로지에 최적화된 비행기 날개, PrusaSlicer로 만든 노비라는 모델이 포함되었습니다.

메시렛 디스크립터 비교

동일한 실험 설정을 적용하여 가장 성능이 좋은 메시 생성 알고리즘을 사용하여 다양한 메시 설명자를 테스트했습니다. 이 접근 방식을 통해 메시 클러스터링 방법뿐만 아니라 이러한 방법의 맥락에서 다양한 메시 기술자의 효율성을 종합적으로 평가할 수 있었습니다.

![6개의 메시를 기반으로 한 트라이앵글의 평균 렌더링 시간. 메쉬렛 컬링이 적용된 렌더링 시간은 점선으로 표시하고, 컬링이 적용되지 않은 렌더링 시간은 실선으로 표시했습니다.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%205.png)

6개의 메시를 기반으로 한 트라이앵글의 평균 렌더링 시간. 메쉬렛 컬링이 적용된 렌더링 시간은 점선으로 표시하고, 컬링이 적용되지 않은 렌더링 시간은 실선으로 표시했습니다.

요약하면, 이 섹션에서는 다양한 메시클릿 클러스터링 알고리즘을 평가하고 비교하는 데 사용된 세심하고 통제된 실험적 접근 방식에 대해 자세히 설명합니다. 다양한 3D 모델과 일관된 테스트 환경을 포함하는 이 설정은 각 알고리즘의 성능을 명확하게 이해하고 다양한 하드웨어 설정에 걸쳐 일반화할 수 있는 메시 생성 원리를 파악하기 위해 고안되었습니다.

1. 메시클릿 클러스터링 알고리즘 비교 결과

일반적인 추세 및 컬링 분석

이 연구의 결과는 다양한 메시클릿 클러스터링 알고리즘의 효율성에 대한 인사이트를 제공합니다. 주요 관찰 사항은 메시클릿 컬링 유무에 따른 트라이앵글 수에 따른 렌더링 시간의 선형적 추세입니다. 이 연구는 또한 각 메시의 백페이스 및 프러스텀 컬링의 정도를 보여줍니다. 특히 노비(Nobby)와 해피 붓다(Happy Buddha)와 같은 일부 메시는 지오메트리 때문에 백페이스 컬링이 발생하지 않아 알고리즘의 성능에 영향을 미쳤습니다.

![5가지 클러스터링 알고리즘을 사용할 때 각 프레임에서 컬링되는 메시의 평균 비율. 컬링된 메시클릿은 두 가지로 나뉘며, 백페이스 컬링된 메시클릿은 완전히 불투명한 막대로 표시되고 프러스텀 컬링된 메시클릿은 반투명한 막대로 표시됩니다.](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%206.png)

5가지 클러스터링 알고리즘을 사용할 때 각 프레임에서 컬링되는 메시의 평균 비율. 컬링된 메시클릿은 두 가지로 나뉘며, 백페이스 컬링된 메시클릿은 완전히 불투명한 막대로 표시되고 프러스텀 컬링된 메시클릿은 반투명한 막대로 표시됩니다.

다양한 알고리즘의 성능

실제 렌더링 시간은 메시의 크기에 따라 달랐습니다. 큰 모델의 경우 알고리즘 간에 상당한 성능 차이가 있었습니다. 연구원들은 회귀선을 피팅하여 삼각형당 나노초 단위의 기울기를 도출하여 각 방법의 효율성을 비교 측정했습니다. 바운딩 스피어 알고리즘이 가장 작은 기울기를 보였으며, 이는 트라이앵글 수가 증가해도 렌더링 시간이 거의 증가하지 않음을 나타냅니다. 또한 이 연구에서는 NVIDIA의 알고리즘은 단순하지만 성능 면에서 단점이 있었고, 카풀카인의 알고리즘은 복잡하지만 우수한 렌더링 시간을 달성한 것으로 나타났습니다.

메시렛 완성도와 그 영향

K-메도이드를 제외한 모든 알고리즘은 메시렛에서 높은 평균 정점 수를 달성했습니다. 하지만 이러한 정점 완성도는 렌더링 시간의 차이를 크게 설명하지 못했습니다. 반면, 평균 프리미티브 채우기(메시렛에서 프리미티브의 최대 수에 대한 프리미티브의 비율)는 더 다양하게 변화했으며 성능과 상관관계가 있었습니다. 프리미티브 채우기가 높은 알고리즘이 일반적으로 더 나은 성능을 보였습니다. NVIDIA의 알고리즘은 각각 더 적은 수의 프리미티브를 가진 더 많은 메시클릿을 생성했기 때문에 더 많은 수의 메시클릿이 필요했습니다.

![Nobby의 긴 원통형 메시렛 시각화(왼쪽)와 Happy Buddha의 표면 거칠기를 보여주는 노멀 시각화(오른쪽).](Performance%20Comparison%20of%20Meshlet%20Generation%20Strat%20b1dd2dc0756b46d59d1bdb3cd0057b34/Untitled%207.png)

Nobby의 긴 원통형 메시렛 시각화(왼쪽)와 Happy Buddha의 표면 거칠기를 보여주는 노멀 시각화(오른쪽).

메시클릿 크기와 컬링 가능성이 성능에 미치는 영향

버텍스와 프리미티브 측면에서 메시클릿의 크기 분포가 성능에 영향을 미쳤습니다. 프리미티브 채우기를 기준으로 메시클릿을 정렬하면 GPU에 더 균일한 부하가 발생하여 렌더링 시간이 개선되었습니다. 이러한 균일성은 GPU에서 효율적인 병렬 처리가 가능하기 때문에 매우 중요했습니다. 또한 이 연구에서는 메시렛 컬링의 영향도 조사했습니다. 메시의 공간 일관성을 강화하면 메시가 더 콤팩트해져 컬링될 가능성이 높아져 작은 메시의 경우 성능이 향상되었지만 큰 메시의 경우 그다지 향상되지 않았습니다.

메시렛 설명자 비교

이 연구에서는 바운딩 스피어 알고리즘을 사용하여 네 가지 메시릿 설명자를 비교했습니다. 성능은 메시마다 달랐으며, 각 메시마다 가장 적합한 설명자 유형이 달랐습니다. 노비 모델의 경우 모놀리식 디스크립터가 가장 효과적이었는데, 이는 뒷면 컬링을 제한하는 지오메트리로 인해 보이는 모든 메시를 처리해야 했기 때문인 것으로 보입니다. 이는 특히 컬링이 최소화되는 경우 메시렛 컬링이 성능에 미치는 영향을 강조했습니다.

요약하자면, 이 연구 결과는 다양한 메시 클러스터링 알고리즘의 성능에 대한 귀중한 인사이트를 제공하며, 각 방법의 효율성은 메시 크기와 복잡성에 따라 달라집니다. 이 연구 결과는 렌더링 성능을 최적화할 때 메시 크기, 완전성, 컬링 가능성을 고려하는 것이 중요하다는 점을 강조합니다. 또한 각 메시의 특정 특성에 따라 달라지는 메시릿 설명자의 선택도 중요한 역할을 합니다.

### 6. Discussion

정점 완전성과 그 중요성

이 연구는 메시렛 생성에서 정점 완전성의 중요성을 강조합니다. 정점 완성도가 낮은 K-메도이드 접근 방식은 다른 방식에 비해 렌더링 효율이 떨어졌습니다. 공간적으로 일관된 메시클릿은 더 많은 메시클릿을 생성하지만 컬링 가능성을 개선했지만 성능 향상을 위해 높은 수준의 정점 완성도를 유지하는 것이 중요하다는 것을 보여주었습니다.

버텍스와 프리미티브 채우기의 균형

이 연구에서 관찰된 바와 같이 높은 프리미티브 채우기는 더 나은 성능과 상관관계가 있습니다. 그러나 거의 정점이 완성된 메시 없이 높은 프리미티브 채우기를 달성하는 것은 어려운 일입니다. 이 연구는 최적의 성능을 위해 버텍스 완전성과 프리미티브 채우기의 균형을 맞추는 것이 이상적인 전략임을 시사합니다. 이러한 균형은 다양한 메시에서 NVIDIA 및 k-medoids 컬렉션의 서로 다른 성능에서 분명하게 드러났으며, 두 가지 요소를 동시에 고려해야 할 필요성을 강조합니다.

메시렛의 컬링 가능성 및 균일성

컬링 가능성은 버텍스 완전성이나 프리미티브 채우기보다는 덜 영향력이 있지만 여전히 성능 최적화에 중요한 역할을 합니다. 컬링 가능성이 높은 메쉬렛은 특히 메쉬렛 수가 많은 컬렉션에서 성능을 향상시킬 수 있습니다. 정렬된 NVIDIA 컬렉션에서 볼 수 있듯이 메시클릿 크기의 균일성도 GPU 전체에 워크로드가 더 고르게 분산되도록 하여 렌더링 시간을 단축하는 데 기여합니다.

알고리즘 효율성 및 복잡성

놀랍게도 일부 알고리즘은 특정 메시에서 예상대로 작동하지 않았으며, 이는 메시마다 맞춤형 접근 방식이 필요할 수 있음을 나타냅니다. 메시 생성에서 메트릭과 요소의 상호 연결성은 이 프로세스를 최적화하는 것이 얼마나 복잡한지를 잘 보여줍니다. 따라서 그리디 알고리즘과 같이 간단하면서도 효과적인 알고리즘이 실제 애플리케이션에 유용하게 활용될 수 있습니다.

### 7. Conclusion

이 연구는 메시클릿 수를 최소화하면서 메시클릿당 트라이앵글을 최대화하는 메시클릿 컬렉션이 NVIDIA 하드웨어에서 최고의 성능을 발휘한다는 결론을 내렸습니다. 일반적으로 정점에 비해 트라이앵글의 상한이 더 높기 때문에 정점 재사용에 집중하는 것이 중요합니다. 효율적인 메시클릿 생성을 위해 먼저 버텍스 완전성을 확보한 다음 프리미티브 채우기를 최대화하는 전략을 제안합니다. 컬링 가능한 메시렛을 사용하는 것이 좋지만, 메시렛 컬렉션 크기를 크게 늘릴 필요는 없습니다.

균일한 워크로드 및 메시렛 설명자

이 연구에서 입증된 바와 같이 GPU 전체에 균일한 워크로드를 적용하면 성능이 향상됩니다. 다른 메시렛 디스크립터는 렌더링 시간에 큰 영향을 미치지 않았지만, 모놀리식 디스크립터는 특히 과학 시각화의 분산 시스템에서 잠재적인 이점을 보여주었습니다.

향후 연구 방향

향후 연구에서는 메시 셰이더에서 데이터 언패킹을 덜 필요로 하는 디스크립터를 탐색할 수 있습니다. 특히 디스크립터를 분할해도 성능에 영향을 미치지 않는 상황에서 디스크립터에 새로운 메타데이터를 추가하는 방법을 연구하면 렌더링 성능을 더욱 향상시킬 수 있습니다.