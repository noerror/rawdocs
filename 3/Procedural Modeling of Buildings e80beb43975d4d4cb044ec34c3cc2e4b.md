# Procedural Modeling of Buildings

[https://peterwonka.net/Publications/pdfs/2006.SG.Mueller.ProceduralModelingOfBuildings.final.pdf](https://peterwonka.net/Publications/pdfs/2006.SG.Mueller.ProceduralModelingOfBuildings.final.pdf)

- 2006

![이 그림은 컴퓨터 그래픽 건축의 절차적 모델링을 위한 새로운 형태 문법인 CGA shape의 적용을 보여줍니다. 먼저 문법이 부피 형태를 사용하여 건물 질량 모델의 절차적 변형을 생성하고, 그 다음으로 질량 모델과 일관된 외관 세부 사항을 생성합니다. 맥락에 민감한 규칙을 사용하여 창문이나 문이 다른 벽과 교차하지 않도록 하고, 문이 테라스나 거리 수준에 연결되도록 하며, 테라스는 난간으로 경계 지어지도록 합니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled.png)

이 그림은 컴퓨터 그래픽 건축의 절차적 모델링을 위한 새로운 형태 문법인 CGA shape의 적용을 보여줍니다. 먼저 문법이 부피 형태를 사용하여 건물 질량 모델의 절차적 변형을 생성하고, 그 다음으로 질량 모델과 일관된 외관 세부 사항을 생성합니다. 맥락에 민감한 규칙을 사용하여 창문이나 문이 다른 벽과 교차하지 않도록 하고, 문이 테라스나 거리 수준에 연결되도록 하며, 테라스는 난간으로 경계 지어지도록 합니다.

## 1 Introduction

영화와 컴퓨터 게임의 성공을 위해서는 매력적인 모델을 만드는 것이 중요합니다. 그러나 도시와 같은 큰 3D 환경을 모델링하는 것은 매우 비용이 많이 들고 수년간의 노력이 필요합니다. 이 논문에서는 수십억 개의 폴리곤을 가진 대도시를 효율적으로 생성할 수 있는 형태 문법을 사용한 절차적 모델링을 통해 이 문제를 해결합니다. 이 방법은 기존 모델링 소프트웨어로는 재현하기 어려운 높은 기하학적 세부 사항을 포함합니다.

형태 문법(CGA Shape)은 생산 규칙을 사용하여 점점 더 많은 세부 사항을 추가해 나가는 디자인을 진화시킵니다. 건물의 경우, 초기에는 대략적인 볼륨 모델인 질량 모델을 생성하고, 이어서 외관을 구조화하고 창문, 문, 장식 등의 세부 사항을 추가합니다. 이 방법의 주요 장점은 계층 구조의 생성과 모델의 주석 달기가 모델링 과정에서 지정된다는 것입니다. 이는 설계 규칙을 절차적으로 변형하여 다양한 건축물을 생성하는 데 중요합니다.

도시 환경을 모델링하는 아이디어는 Parish와 Müller (2001) 및 Wonka 등(2003)에 의해 탐구되었습니다. Parish와 Müller는 각 건물이 간단한 질량 모델과 외관 세부 사항을 위한 셰이더로 구성된 대도시 환경을 생성하는 방법을 제시했습니다. 반면에, Wonka 등(2003)은 개별 건물의 외관에 기하학적 세부 사항을 추가하는 방법을 시연했습니다. 이 두 아이디어를 결합하여 크고 상세한 도시 환경을 생성하고자 하지만, 질량 모델링의 맥락에서 해결해야 할 중요한 과제가 있습니다.

### 1.1 관련 연구

절차적 모델링은 다양한 생산 시스템에서 영감을 받을 수 있습니다. 그러나 생산 시스템의 단순한 명세는 시작에 불과합니다. 여러 질문, 예를 들어 기하학적 해석, 간결한 표기법, 도출의 제어, 실제 모델의 설계 등이 여전히 해결되어야 합니다.

![우리의 새로운 형태 문법에 대한 동기입니다. 모델링된 건물은 확률적 형태 문법에 의해 배치된 14개의 부피 프리미티브(큐브, 지붕)로 구성됩니다. 왼쪽: 기존의 절차적 건축 방법은 개별 부피에 셰이더를 배치하거나 절차적 세부화를 위한 분할 규칙을 사용할 수 있습니다. 이 경우 여러 원치 않는 교차가 창문(또는 다른 요소)을 부자연스러운 방식으로 자르게 됩니다. 오른쪽: 우리의 접근 방식은 이러한 충돌을 해결할 수 있습니다. 또한, 다양한 방향의 폴리곤(예: 지붕 표면)에 지오메트리를 배치할 수 있습니다. 이 예제는 단 6개의 규칙만으로 생성되었습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%201.png)

우리의 새로운 형태 문법에 대한 동기입니다. 모델링된 건물은 확률적 형태 문법에 의해 배치된 14개의 부피 프리미티브(큐브, 지붕)로 구성됩니다. 왼쪽: 기존의 절차적 건축 방법은 개별 부피에 셰이더를 배치하거나 절차적 세부화를 위한 분할 규칙을 사용할 수 있습니다. 이 경우 여러 원치 않는 교차가 창문(또는 다른 요소)을 부자연스러운 방식으로 자르게 됩니다. 오른쪽: 우리의 접근 방식은 이러한 충돌을 해결할 수 있습니다. 또한, 다양한 방향의 폴리곤(예: 지붕 표면)에 지오메트리를 배치할 수 있습니다. 이 예제는 단 6개의 규칙만으로 생성되었습니다.

식물의 기하학적 모델링에서는 Prusinkiewicz와 Lindenmayer가 L-시스템을 사용하여 뛰어난 결과를 얻을 수 있음을 보여주었습니다. L-시스템은 거북이 위치를 쿼리하도록 확장되었고, 일반 컴퓨터 시뮬레이션과 결합되었습니다.

건축 분야에서는 형태 문법이 건축 설계의 생성과 분석에 성공적으로 사용되었습니다. 형태 문법의 원래 공식은 라벨이 있는 선과 점의 배열에 직접 작용하지만, 도출이 본질적으로 복잡하여 수작업으로 수행되거나 컴퓨터로 수행될 때 규칙 적용을 사람이 결정해야 합니다. 형태 문법은 집합 문법으로 단순화되어 컴퓨터 구현에 더 적합하게 만들 수 있습니다.

### 1.2 개요

이 논문의 구조는 다음과 같습니다. 2장에서는 기본 형태 문법을 설명하고, 3장에서는 복잡한 형태 구성과 상호 작용을 모델링할 수 있는 확장을 소개합니다. 4장, 5장, 6장에서는 여러 모델링 문제에 대한 문법의 적용 사례를 보여줍니다. 7장에서는 더 큰 도시 환경으로의 확장을 보여줍니다. 8장에서는 우리의 기여와 접근 방식의 장단점을 논의하며, 9장에서는 결론을 제시합니다.

## 2 A Shape Grammar for CG Architecture

CGA Shape는 Wonka 등(2003)에 의해 소개된 집합 문법(Set Grammar)의 확장입니다. 기존 연구에서 분할 규칙의 개념이 도입되었지만, 이번 연구에서는 반복 분할과 규칙의 스케일링, 그리고 일차원, 이차원, 삼차원 형태 모델링을 위한 컴포넌트 분할을 추가로 정의합니다. 이는 L-시스템의 영향을 받았으나 건축 모델링에 맞게 확장되었습니다.

![왼쪽: 형태의 범위. 점 P와 세 축 X, Y, Z 및 크기 S가 형태를 포함하는 공간 내의 상자를 정의합니다. 오른쪽: 세 개의 형태 프리미티브로 구성된 간단한 건물 질량 모델.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%202.png)

왼쪽: 형태의 범위. 점 P와 세 축 X, Y, Z 및 크기 S가 형태를 포함하는 공간 내의 상자를 정의합니다. 오른쪽: 세 개의 형태 프리미티브로 구성된 간단한 건물 질량 모델.

### 형태의 구성

형태는 기호(문자열), 기하 속성(위치, 크기 등), 숫자 속성으로 구성됩니다. 기호는 터미널 기호와 비터미널 기호로 구분되며, 각각 터미널 형태와 비터미널 형태를 나타냅니다. 중요한 기하 속성으로는 위치 P, 세 개의 직교 벡터 X, Y, Z, 크기 벡터 S가 있으며, 이들은 공간 내의 경계 상자를 정의합니다.

![왼쪽: 기본 외관 디자인. 오른쪽: 상위 세 층에 사용할 수 있는 간단한 분할.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%203.png)

왼쪽: 기본 외관 디자인. 오른쪽: 상위 세 층에 사용할 수 있는 간단한 분할.

### 생산 과정

생산 과정은 임의의 형태 구성(Axiom)에서 시작하여 다음과 같이 진행됩니다:

1. 활성 형태 선택
2. 선택된 형태에 대한 생산 규칙 적용
3. 선택된 형태를 비활성으로 표시하고, 새로 생성된 형태를 구성에 추가

이 과정은 비터미널 형태가 더 이상 없을 때까지 반복됩니다. 도출 트리는 깊이 우선 또는 너비 우선으로 탐색할 수 있지만, 우리는 세부 사항에 따라 우선순위를 부여하여 제어된 너비 우선 도출을 사용합니다.

### 표기법

생산 규칙은 다음과 같은 형식으로 정의됩니다:

```bash
id: 선행자 : 조건 --> 후속자 : 확률
```

예를 들어, 다음 규칙은 높이(h)가 9보다 클 때 fac를 세 개의 floor로 대체합니다:

```css
1: fac(h) : h > 9 --> floor(h/3) floor(h/3) floor(h/3)
```

### 범위 규칙

L-시스템과 유사하게 형태를 수정하기 위한 일반 규칙을 사용합니다. 예를 들어, T(tx, ty, tz)는 위치 P에 번역 벡터를 추가하고, Rx(angle), Ry(angle), Rz(angle)은 각각의 축을 회전시키며, S(sx, sy, sz)는 크기를 설정합니다.

### 기본 분할 규칙

기본 분할 규칙은 현재 범위를 한 축을 따라 분할합니다. 예를 들어, 다음 규칙은 외관을 네 개의 층과 하나의 선반으로 분할합니다:

```c
1: fac --> Subdiv("Y", 3.5, 0.3, 3, 3, 3) { floor | ledge | floor | floor | floor }
```

### 규칙의 스케일링

규칙을 다양한 범위에서 작동하게 하려면 절대 값과 상대 값을 구분할 필요가 있습니다. 기본적으로 값은 절대 값으로 간주되며, 상대 값을 나타내기 위해 'r'을 사용합니다:

```css
1: floor --> Subdiv("X", 2, 1r, 1r, 2) { B | A | A | B }
```

### 반복

다음 규칙은 요소를 타일링하여 현재 범위의 x축을 따라 여러 번 반복합니다:

```css
1: floor --> Repeat("X", 2) { B }
```

### 컴포넌트 분할

다음 명령어는 형태를 차원 감소된 형태로 분할합니다:

```css
1: a --> Comp(type, param) { A | B | ... | Z }
```

예를 들어, 다음 규칙은 원래 형태의 각 면에 A라는 기호를 생성합니다:

```less
Comp("faces") { A }
```

CGA Shape는 이러한 규칙을 사용하여 복잡한 형태 구성을 정의하고, 이를 통해 건축 모델을 생성하는 강력한 도구입니다.

## 3 Mass Modeling

이 장에서는 질량 모델을 생성하는 방법과 외관 및 지붕 세부 사항을 생성하는 방법을 설명합니다. 제안된 기술은 형태 규칙의 결과가 공간적 맥락에 따라 달라지도록 허용하여, 질량 모델링에서 외관 및 지붕 모델링으로의 전환을 해결합니다.

### 3.1 솔리드의 조합

건물 질량 모델은 볼륨 형태의 합으로 가장 자연스럽게 구성됩니다. 간단한 건축 블록과 회전을 포함한 복잡한 질량 모델을 생성할 수 있습니다.

![질량 모델링을 위한 기본 형태 어휘.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%204.png)

질량 모델링을 위한 기본 형태 어휘.

1. **기본적인 형태 조합**: 간단한 박스를 기본 프리미티브로 사용하여 건물 질량 모델을 생성할 수 있습니다. 스케일링, 번역 또는 분할을 통해 기본 빌딩 블록(L, H, U, T 형태)을 생성합니다.
2. **복잡한 형태 조합**: 임의의 회전과 원통을 포함한 형태를 추가하여 더 복잡한 질량 모델을 생성합니다. 예를 들어, 말레이시아의 페트로나스 타워는 회전과 테이퍼링을 사용하여 생성되었습니다.
    
    ![페트로나스 타워의 CGA shape 재구성. 타워의 질량 모델(왼쪽)과 발자국(가운데)은 큐브와 실린더의 기본 조립을 보여줍니다. 오른쪽: 동일한 외관 규칙이 다양한 종류의 고체에 적용되었습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%205.png)
    
    페트로나스 타워의 CGA shape 재구성. 타워의 질량 모델(왼쪽)과 발자국(가운데)은 큐브와 실린더의 기본 조립을 보여줍니다. 오른쪽: 동일한 외관 규칙이 다양한 종류의 고체에 적용되었습니다.
    
3. **지붕 형태 포함**: 기본 지붕 형태(예: 피라미드형 지붕)와 일반 L자형 및 일반 사각형을 포함한 형태를 추가합니다.
    
    ![선택된 지붕 유형들. 왼쪽부터 오른쪽으로: 겜브럴, 원뿔형, 박공지붕, 힙지붕, 교차 박공지붕, 만사드 지붕.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%206.png)
    
    선택된 지붕 유형들. 왼쪽부터 오른쪽으로: 겜브럴, 원뿔형, 박공지붕, 힙지붕, 교차 박공지붕, 만사드 지붕.
    

### 질량 모델 생성 방법

1. **건축 부지 기반**: 문법의 공리로 주어진 건축 부지를 사용하여 스케일링, 번역, 회전 및 분할 작업을 통해 질량 모델을 생성합니다. 이 경우 건물 질량이 부지 경계를 초과하지 않도록 주의해야 합니다.
2. **GIS 데이터베이스 기반**: GIS 데이터베이스 또는 기존 건축 모델을 가져와 소규모 수정만 허용합니다. 가져온 질량 모델을 기존 형태 어휘에 맞추려고 시도하거나, 일반적으로 추출된 윤곽과 지붕을 사용합니다.

### 복잡한 표면 문제

복잡한 표면을 처리하는 문제는 다음과 같은 어려움을 포함합니다:

![단순한 부피 형태의 합집합은 건물 외피에 복잡한 폴리곤을 생성합니다: 결과 폴리곤은 오목할 수 있으며, 많은 꼭지점과 여러 개의 구멍(왼쪽의 빨간색 표시)을 가질 수 있습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%207.png)

단순한 부피 형태의 합집합은 건물 외피에 복잡한 폴리곤을 생성합니다: 결과 폴리곤은 오목할 수 있으며, 많은 꼭지점과 여러 개의 구멍(왼쪽의 빨간색 표시)을 가질 수 있습니다.

1. **가시 표면 계산의 복잡성**: 가시 표면은 일반적인 폴리곤일 수 있으며, 이를 계산하는 것은 간단하지 않습니다.
2. **형태 규칙 작성의 어려움**: 일반적인 폴리곤에 대해 의미 있는 형태 규칙을 작성하는 것은 명확하지 않습니다.
3. **비터미널 기호 할당 문제**: 표면이 알고리즘의 출력이기 때문에 외관 문법을 위한 비터미널 기호를 할당하는 간단한 메커니즘이 없습니다.

### 모델링 전략

제안된 모델링 전략은 다음과 같습니다:

1. **삼차원 범위를 사용한 질량 모델 생성**: 삼차원 범위를 사용하여 질량 모델을 형성하는 삼차원 형태를 배치합니다.
2. **이차원 범위를 사용한 외관 및 지붕 표면 생성**: 삼차원 형태의 면을 추출하여 외관 및 지붕 표면과 정렬된 이차원 범위를 생성합니다.
3. **일차원 범위를 사용한 에지 추출**: 에지를 생성하여 일차원 범위를 생성합니다.

이 모델링 전략은 다양한 질량 모델 구성에서 작동하며, 삼차원 형태에서 이차원 및 일차원 범위로 전환한 후 다시 삼차원 형태로 대체됩니다. 일관된 설계를 위한 두 가지 메커니즘을 사용합니다:

1. **가리기(occlusion) 테스트**: 형태 간의 교차를 테스트하여, 현재 선택된 형태가 다른 형태에 의해 가려지는지 확인합니다.
2. **스냅(snap) 테스트**: 중요한 선 및 평면에 대한 근접성을 테스트하여, 외관 구조를 더 정렬되게 배치합니다.

### 3.2 가리기(occlusion)

가리기 쿼리는 형태 간의 교차를 테스트합니다. 가장 간단한 쿼리는 현재 선택된 형태가 다른 어떤 형태에 의해 가려지는지 테스트합니다. 결과는 "없음", "부분적", 또는 "완전"일 수 있습니다. 예를 들어, 다음 규칙은 타일이 가려지지 않으면 문으로 대체합니다:

```css
1: tile : Shape.occ("all") == "none" -> door
```

다양한 쿼리 변형을 통해 활성 형태, 특정 라벨이 있는 형태, 부모 형태를 제외한 모든 형태를 테스트할 수 있습니다.

### 3.3 스냅(snap)

스냅 테스트는 외관 요소를 더 정렬되게 배치합니다. 스냅 라인은 글로벌 건설 평면으로 저장되며, 외관의 반복 분할 및 세분화 분할에 영향을 줍니다. 스냅 라인의 사용 예시는 다음과 같습니다:

```c
1: floors --> Repeat("Y", floor height) { floor Snap("XZ") }
2: entrance --> Snap("Y", "entrancesnap") door
3: floor --> Repeat("XS", tile width) { tile }
```

![이 그림은 스냅 라인(빨간색)의 효과를 보여줍니다. 왼쪽: 범위를 스냅 라인에 반응하지 않는 반복 분할로 나눕니다(상단). 스냅된 버전의 반복 분할은 먼저 범위를 스냅 라인으로 나누고, 각 절반에 대해 반복을 호출하여 모든 형태 크기를 변경합니다. 오른쪽: 세분화 분할은 스냅 라인에 가장 가까운 분할선만 변경합니다. 스냅 라인에 인접한 두 형태만 변경됩니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%208.png)

이 그림은 스냅 라인(빨간색)의 효과를 보여줍니다. 왼쪽: 범위를 스냅 라인에 반응하지 않는 반복 분할로 나눕니다(상단). 스냅된 버전의 반복 분할은 먼저 범위를 스냅 라인으로 나누고, 각 절반에 대해 반복을 호출하여 모든 형태 크기를 변경합니다. 오른쪽: 세분화 분할은 스냅 라인에 가장 가까운 분할선만 변경합니다. 스냅 라인에 인접한 두 형태만 변경됩니다.

![ 왼쪽: 스냅 라인으로 생성된 건물. 건물의 얇은 선은 문법 구조를 보여주는 최종 형태의 범위를 나타냅니다. 모든 고체 위에 층 수준이 자동으로 정렬되는 것을 볼 수 있습니다. 예를 들어, 테이퍼링 아래에 더 높은 층이 강제되었습니다(일반적인 고층 빌딩 특징). 오른쪽: 건설 중에 사용된 스냅 라인.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%209.png)

 왼쪽: 스냅 라인으로 생성된 건물. 건물의 얇은 선은 문법 구조를 보여주는 최종 형태의 범위를 나타냅니다. 모든 고체 위에 층 수준이 자동으로 정렬되는 것을 볼 수 있습니다. 예를 들어, 테이퍼링 아래에 더 높은 층이 강제되었습니다(일반적인 고층 빌딩 특징). 오른쪽: 건설 중에 사용된 스냅 라인.

### 3.4 구현

형태와 스냅 라인을 저장하고 공간 쿼리를 수행하기 위해 옥트리(oct

ree)를 가속화 데이터 구조로 사용합니다. 이는 런타임에서 빈번한 형태 구성을 수정하는 데 단순성을 제공합니다. 또한, 디스크리트 데이터 구조(수정된 옥트리)를 사용해 실험합니다. 또 다른 가속화 전략으로는 형태가 아닌 범위의 가리기 쿼리를 사용하는 것입니다. 예를 들어, Scope.occ를 사용하여 현재 범위의 가리기를 테스트할 수 있습니다. 스냅 라인의 계산을 위해서는 [Mantyla 1986]에 기반한 분할 알고리즘을 사용합니다.

![왼쪽: 부피 모델. 오른쪽: 가려진 외관 표면과 교차된 대략적인 가리기 데이터 구조가 빨간색으로 표시됩니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2010.png)

왼쪽: 부피 모델. 오른쪽: 가려진 외관 표면과 교차된 대략적인 가리기 데이터 구조가 빨간색으로 표시됩니다.

### 요약

이 장에서는 CGA Shape 형태 문법을 사용하여 질량 모델을 생성하는 방법을 자세히 설명합니다. 다양한 솔리드 형태를 조합하여 복잡한 건물 질량 모델을 만들고, 이차원 및 일차원 범위로 분할하여 외관과 지붕 세부 사항을 생성하는 방법을 소개합니다. 가리기 및 스냅 테스트를 통해 형태 간의 교차를 관리하고, 외관 구조를 더 정렬되게 배치하는 전략을 설명합니다. 최종적으로, 이 모든 과정을 효율적으로 구현하기 위해 옥트리와 같은 가속화 데이터 구조를 사용하는 방법을 제시합니다.

## 4 A Simple Building Model

이 장에서는 형태 문법을 사용하여 간단한 건물 모델을 생성하는 방법을 소개합니다. 예제 문법을 통해 인간이 읽기 쉽고 재사용 가능한 규칙을 사용하여 건물을 모델링하는 과정을 설명합니다. 이 예제는 건물 외관과 지붕을 포함한 전체 모델을 생성합니다.

![왼쪽 상단은 4장에서 설명한 규칙으로 생성된 건물을 보여줍니다. 다른 세 모델은 문법을 확장하여 생성되었습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2011.png)

왼쪽 상단은 4장에서 설명한 규칙으로 생성된 건물을 보여줍니다. 다른 세 모델은 문법을 확장하여 생성되었습니다.

![ 왼쪽: 간단한 문법이 세 가지 다른 발자국에 적용됩니다. 가리기 쿼리가 두 이웃 건물의 교차점에 창문을 배치하지 않는 방식을 주목하십시오. 오른쪽: 지붕은 지붕 평면과 지붕 가장자리에 벽돌로 모델링되었습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2012.png)

 왼쪽: 간단한 문법이 세 가지 다른 발자국에 적용됩니다. 가리기 쿼리가 두 이웃 건물의 교차점에 창문을 배치하지 않는 방식을 주목하십시오. 오른쪽: 지붕은 지붕 평면과 지붕 가장자리에 벽돌로 모델링되었습니다.

### 예제 문법 개요

이 예제 문법은 건물 발자국(footprint)을 시작으로 간단한 일반 건물을 생성합니다. 각 규칙은 가독성을 고려하여 작성되었으며, 건축 어휘를 일관되게 사용합니다.

### 주요 개념

1. **가독성**: 규칙은 사람이 읽기 쉽고 다른 사용자가 이해할 수 있도록 작성되었습니다. 매개변수는 이탤릭체로 표시되며, 일관된 건축 어휘를 사용합니다.
2. **가리기(occlusion)**: 문법은 건물 발자국이 다른 건물과 교차하는 부분에 창문과 문을 배치하지 않습니다.
3. **지붕 구조**: 지붕 구조를 만드는 과정을 설명합니다. 벽돌 배치와 같은 세부 사항을 생성합니다.

### 규칙 설명

- **우선 순위 1**: 기본 건물 외관과 지붕을 생성하는 규칙입니다.
    
    ```css
    1: footprint --> S(1r, building height, 1r) facades
       T(0, building height, 0) Roof("hipped", roof angle) { roof }
    ```
    
    이 규칙은 건물 발자국을 사용하여 건물 외관을 생성하고, 지붕을 추가합니다.
    
- **우선 순위 2**: 외관과 창문, 문을 생성하는 규칙입니다.
    
    ```css
    2: facades --> Comp("sidefaces") { facade }
    3: facade : Shape.visible("street")
       --> Subdiv("X", 1r, door width * 1.5) { tiles | entrance } : 0.5
       --> Subdiv("X", door width * 1.5, 1r) { entrance | tiles } : 0.5
    4: facade --> tiles
    5: tiles --> Repeat("X", window spacing) { tile }
    6: tile --> Subdiv("X", 1r, window width, 1r) { wall | Subdiv("Y", 2r, window height, 1r) { wall | window | wall } | wall }
    7: window : Scope.occ("noparent") != "none" --> wall
    8: window --> S(1r, 1r, window depth) I("win.obj")
    9: entrance --> Subdiv("X", 1r, door width, 1r) { wall | Subdiv("Y", door height, 1r) { door | wall } | wall }
    10: door --> S(1r, 1r, door depth) I("door.obj")
    11: wall --> I("wall.obj")
    ```
    
- **우선 순위 3**: 지붕과 지붕 세부 사항을 생성하는 규칙입니다.
    
    ```scss
    12: roof --> Comp("sidefaces") { covering }
        Comp("sideedges") { roofedge } Comp("topedges") { roofedge }
    13: covering --> Repeat("XY", flatbrick width, brick length) { flatbrick }
        Subdiv("X", flatbrick width, 1r) { ε | Repeat("X", flatbrick width) { roofedge } }
    14: roofedge --> Subdiv("Y", overlap, brick length - 2 * overlap, 1r) { ε | roundbrick | Repeat("Y", brick length - overlap) { roundbrick } }
    15: flatbrick --> S(1r, 1r, flatbrick height) T(0, 0, -flatbrick height) Rx(-3) I("flatbrick.obj")
    16: roundbrick --> S(roundbrick w, Scope.sy + overlap, roundbrick h) T(-roundbrick w / 2, -overlap, -roundbrick h) Rx(-3) I("roundbrick.obj")
    ```
    

이 예제는 형태 문법을 사용하여 간단한 건물을 모델링하는 방법을 보여줍니다. 규칙은 가독성을 염두에 두고 작성되었으며, 건물 외관, 창문, 문, 지붕 등을 생성하는 과정을 포함합니다. 가리기 쿼리를 사용하여 건물 발자국이 교차하는 부분에 창문과 문을 배치하지 않도록 하였으며, 지붕 구조를 상세하게 모델링합니다.

## 5 A Model for Office Buildings

이 장에서는 오피스 건물의 질량 모델을 생성하는 규칙 집합을 소개합니다. 먼저, 확률적 문법을 사용하여 다양한 질량 모델을 생성하고, 이어서 외관 세부 사항을 모델링하는 방법을 설명합니다.

![단 4개의 규칙으로 생성된 건물 질량 모델의 확률적 변형(건축 부지를 공리로 시작).](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2013.png)

단 4개의 규칙으로 생성된 건물 질량 모델의 확률적 변형(건축 부지를 공리로 시작).

![스냅 라인으로 모델링된 절차적으로 생성된 건물. 건설에서 중요한 선과 평면의 정렬을 주목하십시오.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2014.png)

스냅 라인으로 모델링된 절차적으로 생성된 건물. 건설에서 중요한 선과 평면의 정렬을 주목하십시오.

### 질량 모델 생성

1. **건축 부지 기반 질량 모델 생성**
    - 건축 부지를 공리로 사용하여 건물 높이를 설정하고, 이를 통해 3차원 형태를 생성합니다. 이 형태는 두 개의 더 작은 형태로 분할됩니다: 주 질량 모델(facades)과 나중에 분할될 두 개의 측면 윙(sidewings) 형태입니다.
    
    ```css
    PRIORITY 1:
    1: lot --> S(1r, building height, 1r)
       Subdiv("Z", Scope.sz * rand(0.3, 0.5), 1r) { facades | sidewings }
    2: sidewings --> Subdiv("X", Scope.sx * rand(0.2, 0.6), 1r) { sidewing | ε }
       Subdiv("X", 1r, Scope.sx * rand(0.2, 0.6)) { ε | sidewing }
    ```
    
2. **측면 윙 생성**
    - 확률적 규칙을 사용하여 다양한 측면 윙의 높이와 너비를 생성합니다. 예를 들어, 측면 윙이 주 질량 모델과 같은 높이일 확률은 50%입니다.
    
    ```css
    3: sidewing
       --> S(1r, 1r, Scope.sz * rand(0.4, 1.0)) facades : 0.5
       --> S(1r, Scope.sy * rand(0.2, 0.9), Scope.sz * rand(0.4, 1.0)) facades : 0.3
       --> ε : 0.2
    4: facades --> Comp("sidefaces") { facade }
    ```
    

### 외관 모델링

1. **주 질량 모델 외관 생성**
    - 주 질량 모델의 외관을 생성하고, 건물의 지배적인 평면(층)을 다른 형태에 강제합니다. 라벨이 있는 스냅 라인과 라벨이 없는 스냅 라인을 사용합니다.
    
    ```css
    PRIORITY 2:
    5: facade : Shape.visible("Street") == 0 -->
       Subdiv("Y", ground floor height, 1r, top floor height)
       { groundfloor | floors | topfloors } fireescape
    ```
    
2. **층과 세부 사항 생성**
    - 층을 생성하고, 지배적인 평면을 형성합니다. 문, 창문, 벽 등의 세부 사항을 생성합니다.
    
    ```arduino
    6: groundfloor --> Subdiv("X", 1r, entrance width, 1r) { groundtiles | entrance SnapLines("Y", "entrancesnap") | groundtiles }
    ```
    
3. **층과 타일 생성**
    - 반복 규칙을 사용하여 여러 층과 타일을 생성하고, 스냅 라인을 사용하여 중요한 구조 요소를 정렬합니다.
    
    ```c
    PRIORITY 3:
    7: facade --> floors
    8: floors --> Repeat("YS", floor height) { floor Snap("XZ") }
    9: floor --> Repeat("XS", tile width) { tile Snap("Y", "tilesnap") }
    ```
    
4. **화재 탈출구 생성**
    - 라벨이 있는 스냅 라인을 사용하여 화재 탈출구를 외관 구조에 맞춰 배치합니다.
    
    ```css
    PRIORITY 4:
    16: fireescape --> Subdiv("XS", 1r, 2 * tile width, 7r, "tilesnap")
       { epsilon | escapestairs | ε }
    17: escapestairs --> S(1r, 1r, fireescape depth)
       T(0, 0, -fireescape depth) Subdiv("YS", ground floor height, 1r)
       { ε | Repeat("YS", floor height) { I("fireescape.obj") } }
    ```
    

### 예제 모델

예제 모델은 확률적 규칙과 스냅 라인을 사용하여 다양한 질량 모델을 생성하는 방법을 보여줍니다. 이 모델은 효율적이며, 다양한 형태와 구조를 쉽게 생성할 수 있습니다. 주요 개념은 다음과 같습니다:

- **질량 모델 생성**: 기본 형태를 다양한 크기와 비율로 조합하여 복잡한 질량 모델을 생성합니다.
- **외관 세부 사항**: 외관 요소를 정렬하고, 스냅 라인을 사용하여 중요한 구조 요소를 배치합니다.
- **확률적 규칙**: 다양한 형태와 구조를 생성하기 위해 확률적 규칙을 사용합니다.

이 장에서는 오피스 건물의 질량 모델을 효율적으로 생성하는 방법과 외관 세부 사항을 모델링하는 방법을 제시합니다.

## 6 A Model for Single Family Homes

이 장에서는 단독 주택을 모델링하는 방법을 소개합니다. 이 모델은 일차원, 이차원, 삼차원 모델링 간의 상호작용을 통해 다양한 구성 요소를 생성하고 배치하는 전략을 설명합니다.

![교외 환경의 다양한 건물. CGA shape는 건물 환경(예: 보도나 식생)의 절차적 생성에도 사용할 수 있습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2015.png)

교외 환경의 다양한 건물. CGA shape는 건물 환경(예: 보도나 식생)의 절차적 생성에도 사용할 수 있습니다.

![CityEngine의 스크린샷, CGA shape 모델링 환경. 메인 창의 왼쪽 패널은 도시 레이아웃을 표시하는 GIS와 유사한 뷰어이며, 오른쪽은 생성된 지오메트리의 선택된 부분을 보여주는 OpenGL 미리보기입니다. 앞쪽 창은 규칙 편집기를 포함합니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2016.png)

CityEngine의 스크린샷, CGA shape 모델링 환경. 메인 창의 왼쪽 패널은 도시 레이아웃을 표시하는 GIS와 유사한 뷰어이며, 오른쪽은 생성된 지오메트리의 선택된 부분을 보여주는 OpenGL 미리보기입니다. 앞쪽 창은 규칙 편집기를 포함합니다.

### 모델링 전략

단독 주택 모델링의 주요 전략은 다음과 같습니다:

1. **부동산 가장자리 분할**: 컴포넌트 분할을 사용하여 부동산 가장자리를 분할하고, 울타리 근처에 관목을 배치합니다.
2. **부동산 분할**: 부동산을 분할하여 앞마당, 뒷마당, 그리고 주요 건물을 모델링합니다.
3. **인도와 나무 배치**: 인도를 생성하고 거리 옆에 나무를 정기적으로 배치합니다. 나무는 Greenwork's Xfrog를 사용하여 생성합니다.
4. **진입로와 경로 생성**: 차고 문과 연결된 진입로, 입구 문과 연결된 경로를 생성합니다.

### 주요 규칙 설명

1. **부동산 가장자리 분할**
    - 컴포넌트 분할을 사용하여 부동산 가장자리를 따라 관목을 배치합니다.
    
    ```css
    1: property --> Comp("edges") { shrub }
    ```
    
2. **부동산 분할**
    - 부동산을 앞마당, 뒷마당, 주요 건물로 분할합니다.
    
    ```css
    2: property --> Subdiv("Z", 0.2, 0.6, 0.2) { frontyard | mainbuilding | backyard }
    ```
    
3. **인도와 나무 배치**
    - 인도를 생성하고, 일정 간격으로 나무를 배치합니다.
    
    ```css
    3: frontyard --> sidewalk
       Repeat("X", tree_spacing) { tree }
    ```
    
4. **진입로와 경로 생성**
    - 차고 문과 연결된 진입로와 입구 문과 연결된 경로를 생성합니다.
    
    ```arduino
    4: mainbuilding --> driveway connected to garage_door
       pathway connected to entrance_door
    ```
    

### 예제 모델

이 예제 모델은 초기 단계에서 겹치더라도 잘 형성된 형태로 작업하고, 나중에 가리기 쿼리를 통해 충돌을 해결합니다. 예를 들어, 인도와 진입로의 교차를 해결하고, 집과 다른 식물 사이에 충분한 거리를 유지합니다.

- **관목 배치**: 부동산 가장자리를 따라 관목을 배치합니다.
    
    ```css
    1: property --> Comp("edges") { shrub }
    ```
    
- **앞마당, 뒷마당, 주요 건물 분할**: 부동산을 세 부분으로 나눕니다.
    
    ```css
    2: property --> Subdiv("Z", 0.2, 0.6, 0.2) { frontyard | mainbuilding | backyard }
    ```
    
- **인도와 나무 배치**: 인도를 생성하고 일정 간격으로 나무를 배치합니다.
    
    ```css
    3: frontyard --> sidewalk
       Repeat("X", tree_spacing) { tree }
    ```
    
- **진입로와 경로 생성**: 진입로와 경로를 생성합니다.
    
    ```arduino
    4: mainbuilding --> driveway connected to garage_door
       pathway connected to entrance_door
    ```
    

단독 주택 모델링에서는 컴포넌트 분할과 가리기 쿼리를 통해 다양한 구성 요소를 생성하고 배치하는 방법을 설명합니다. 초기 단계에서는 겹치는 형태로 작업하며, 나중에 충돌을 해결하여 일관된 모델을 생성합니다. 이러한 전략은 단독 주택의 다양한 구성 요소를 효율적으로 모델링하는 데 유용합니다.

## 7 Results

### 사용자 인터페이스와 워크플로우

CGA Shape의 C++ 구현은 CityEngine 프레임워크에 통합되었습니다. CityEngine은 GIS 데이터, 래스터 맵, Google Earth의 KML 형식 등 다양한 형태의 데이터를 가져올 수 있으며, 다양한 보기 모드를 통해 모델링 과정을 시각적으로 안내합니다. 가장 자주 사용되는 보기 모드로는 건물 발자국, 거리, 부지 경계를 보여주는 개요 모드, 3차원 보기, 최종 지오메트리의 미리보기 모드, 형태 구성과 도출 트리의 시각적 디버깅 도구, 그리고 형태 문법 규칙 편집기 등이 있습니다.

새로운 규칙을 개발하기 위해 구현된 인터랙티브 방법을 사용하여 문법 도출을 모델의 일부(예: 단일 건물이나 건물의 일부)로 제한할 수 있습니다. 사용자가 결과에 만족하면 더 큰 모델을 생성하고 디스크에 저장할 수 있습니다. 모델 생성은 매우 빠르며, 약 5만 폴리곤을 가진 모델을 생성하는 데 약 1초, 디스크에 저장하는 데 약 0.5초가 소요됩니다. 조명과 카메라 애니메이션 설정은 Maya를 사용하며, 수십억 개의 폴리곤을 가진 큰 도시 모델의 렌더링은 Pixar의 RenderMan을 사용하여 메모리 절약 인스턴싱과 신뢰할 수 있는 LOD 기능을 활용합니다.

### 예제 모델

1. **폼페이 모델링**
고대 로마 도시 폼페이를 모델링하기 위해 고고학자들과 협력하여 지상 계획과 선택된 건물 유형의 수치를 제공받았습니다. 이를 바탕으로 190개의 설계 규칙을 추상화하여 거리와 나무 배치를 포함한 전체 도시를 모델링했습니다. 결과 모델은 높은 LOD에서 약 14억 개의 폴리곤, 중간 LOD에서 3100만 개의 폴리곤, 낮은 LOD에서 17만 개의 폴리곤을 가지고 있습니다. 도시의 다양한 높이에서의 뷰와 거리 내부의 뷰를 통해 모델의 세부 사항을 확인할 수 있습니다. 외부 조명은 앰비언트 오클루전으로 시뮬레이션되었습니다.
    
    ![절차적으로 생성된 폼페이 모델의 다양한 뷰. 실제 건물 발자국을 기반으로 도시가 수동으로 작성된 190개의 CGA shape 규칙으로 생성되었습니다. 따라서 전체 모델은 36개의 터미널 객체(4개의 나무 유형과 환경 포함)의 규칙 기반 구성입니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2017.png)
    
    절차적으로 생성된 폼페이 모델의 다양한 뷰. 실제 건물 발자국을 기반으로 도시가 수동으로 작성된 190개의 CGA shape 규칙으로 생성되었습니다. 따라서 전체 모델은 36개의 터미널 객체(4개의 나무 유형과 환경 포함)의 규칙 기반 구성입니다.
    
2. **전문 모델러의 도시 모델링**
사용성 테스트를 위해 전문 모델러를 초대하여 예제 모델을 개발하도록 했습니다. 첫날에는 사용자 인터페이스, 워크플로우, 여러 예제 규칙 집합을 설명했습니다. 이후, 미미한 지원만으로 5장에서 시작된 규칙을 사용하여 독립적으로 작은 도시 모델을 생성했습니다. 이 결과, CGA Shape를 사용한 모델링은 쉽고 효율적임을 확인할 수 있었습니다. 스냅 개념도 성공적으로 이해하고 적용되었습니다.
    
    ![단 2일 만에 처음부터 생성된 현대 도시 모델.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2018.png)
    
    단 2일 만에 처음부터 생성된 현대 도시 모델.
    
3. **비벌리 힐스에서 영감을 받은 모델**
비벌리 힐스의 항공 사진에서 영감을 받아 전체 모델을 절차적으로 생성했습니다. 약 150개의 규칙을 사용하여 부지 분할, 도시 식생, 수영장, 인도, 거리 등을 포함했습니다. 전체 모델은 약 천 개의 건물로 구성되어 있으며, 전체 LOD에서 약 7억 개의 폴리곤을 포함하고 있습니다. 나무는 변환된 인스턴스로 처리됩니다.
    
    ![비벌리 힐스에서 영감을 받은 부유한 교외 지역 모델. CGA shape는 나무 모델을 배치하는 데에도 사용되었습니다.](Procedural%20Modeling%20of%20Buildings%20e80beb43975d4d4cb044ec34c3cc2e4b/Untitled%2019.png)
    
    비벌리 힐스에서 영감을 받은 부유한 교외 지역 모델. CGA shape는 나무 모델을 배치하는 데에도 사용되었습니다.
    

### 논의

이 섹션에서는 이전 작업과의 비교, 기여 및 향후 연구 과제를 논의합니다.

1. **메쉬 모델링 도구와의 비교**
기존 모델링 도구와의 비교는 비공식적으로 이루어집니다. 상용 모델링 소프트웨어에서 스크립팅을 사용하여 모델링 과정을 가속화할 수 있지만, 이러한 스크립트는 아마도 형태 문법의 일부만을 복제할 것입니다. 영화 산업의 예를 들어보면, 영화 "슈퍼맨 리턴즈"의 도시 모델링에는 15년의 인력이 소요되었습니다. 그러나 우리의 모델은 수십억 개의 폴리곤을 포함하여 현재 엔터테인먼트 산업의 모델링 관행보다 훨씬 더 상세합니다. CGA Shape는 기존 3D 모델링 소프트웨어를 대체하려는 것이 아니라, 전체 모델링 환경에 긴밀히 통합된 도구로 사용됩니다.
2. **효율성과 견고성**
형태 문법을 사용한 디자인은 대부분의 경우 견고하고 효율적입니다. 복잡하고 오류가 발생하기 쉬운 기하학적 계산을 실행할 필요가 없기 때문에, 더 단순한 형태의 의미 있는 규칙을 작성하여 복잡한 폴리곤 표면을 생성할 수 있습니다. 전역 최적화는 더 나은 결과를 제공할 수 있지만, 모델링 시간이 매우 길어질 수 있습니다. 반면, 형태 문법 도출은 빠르게 이루어지며, 수십억 개의 폴리곤을 가진 모델을 하루 이내에 생성할 수 있습니다. 절차적 접근 방식의 일반적인 단점은 때때로 불가능한 형태 구성을 생성할 수 있다는 것입니다.
3. **사용성**
CGA Shape 사용에 대한 학습 곡선은 다른 스크립팅 언어와 유사합니다. 규칙은 사람이 읽을 수 있는 형태로 작성되어, 규칙을 재사용하고 다른 사용자와 공유할 수 있습니다. 이를 통해 경험이 적은 사용자도 기존 규칙 집합을 가져와 수정하여 만족스러운 결과를 빠르게 모델링할 수 있습니다. 그러나 부주의하게 작성된 규칙은 원 저자만 이해할 수 있으며, 원치 않는 부작용을 초래할 수 있습니다.
4. **건축 및 컴퓨터 그래픽스**
건축 문헌에서의 규칙은 매우 강력하지만, 보통 추상적이고 과소 명시되어 있어 인간에 의해서만 적용될 수 있습니다. 우리의 형태 문법은 건축 개념을 적용하여 구체적인 형태 규칙을 도출하고, 고품질의 상세한 모델을 생성하는 데 성공했습니다. CGA Shape는 건축 설계보다는 컴퓨터 그래픽스에서 더 성공적으로 적용되었으며, 건축 설계에 적용하기 위해서는 추가적인 연구가 필요합니다.
5. **L-시스템과의 비교**
우리의 작업은 식물 모델링의 선구적인 작업에서 영감을 받았습니다. 유사점으로는 규칙 표기법, 범위 개념, 맥락 민감한 규칙의 필요성 등이 있습니다. 그러나 세부 사항과 모델링 과제는 근본적으로 다릅니다. 우리의 형태 문법은 문자열 대체보다는 형태 대체를 강조합니다. L-시스템을 건축에 직접 적용하면 성장 개념이 과도하게 강조되어, 건물 모델링에는 비생산적일 수 있습니다.
6. **인스턴트 아키텍처와의 비교**
우리의 형태 문법은 스플릿 규칙의 개념을 기반으로 하지만, 스플릿 문법의 엄격한 계층 구조를 더 이상 강제할 수 없습니다. 우리는 맥락 민감한 형태 규칙 모델과 일차원, 이차원, 삼차원 모델링의 상호작용을 우아하고 효율적인 솔루션으로 제안합니다.

### 결론

이 논문은 건물 외피의 절차적 모델링을 위한 새로운 형태 문법인 CGA Shape를 소개합니다. 주요 기여는 건물의 부피 모델링과 지붕 설계입니다. 우리는 스플릿 문법의 여러 확장을 통해 완전한 모델링 시스템을 제공하며, Stiny의 형태 문법 아이디어를 컴퓨터 그래픽스에 성공적으로 적용하였습니다. 이를 통해 산업 및 학계에서 생성된 기존 도시 모델보다 훨씬 더 많은 기하학적 세부 사항을 가진 거대한 도시 모델을 생성할 수 있습니다.

## 8 Discussion

이 섹션에서는 CGA Shape와 기존의 모델링 방법들을 비교하고, 본 연구의 기여 및 향후 연구 방향을 논의합니다.

### 비교

1. **메쉬 모델링 도구와의 비교**
CGA Shape는 기존 메쉬 모델링 도구와는 다른 접근 방식을 취합니다. 상용 모델링 소프트웨어에서는 스크립팅을 통해 모델링 과정을 가속화할 수 있지만, 이는 CGA Shape가 제공하는 형태 문법의 일부만을 복제할 수 있을 뿐입니다. 예를 들어, "슈퍼맨 리턴즈" 영화의 도시 모델링에는 15년의 인력이 소요되었지만, CGA Shape를 사용하면 수십억 개의 폴리곤을 가진 모델을 훨씬 더 빠르게 생성할 수 있습니다. CGA Shape는 기존 3D 모델링 소프트웨어를 대체하려는 것이 아니라, 이를 보완하여 전체 모델링 환경에 통합되는 도구로서 기능합니다.
2. **효율성과 견고성**
CGA Shape를 사용한 모델링은 대부분의 경우 효율적이고 견고합니다. 복잡하고 오류가 발생하기 쉬운 기하학적 계산을 실행할 필요가 없기 때문에, 더 단순한 형태 규칙을 작성하여 복잡한 폴리곤 표면을 생성할 수 있습니다. 형태 문법 도출은 빠르게 이루어지며, 수십억 개의 폴리곤을 가진 모델을 하루 이내에 생성할 수 있습니다. 그러나 절차적 접근 방식은 때때로 불가능한 형태 구성을 생성할 수 있으며, 이는 GIS 데이터세트에서 임의의 건물 발자국을 시작할 때 특히 문제가 됩니다. 이러한 맥락에서 형태 문법을 활용한 형태 이해 연구는 유망한 미래 연구 분야가 될 수 있습니다.
3. **사용성**
CGA Shape의 학습 곡선은 다른 스크립팅 언어와 유사합니다. 우리는 규칙을 사람이 읽을 수 있는 형태로 작성하여, 규칙을 재사용하고 다른 사용자와 공유할 수 있도록 노력했습니다. 이를 통해 경험이 적은 사용자도 기존 규칙 집합을 가져와 수정하여 만족스러운 결과를 빠르게 모델링할 수 있습니다. 그러나 부주의하게 작성된 규칙은 원 저자만 이해할 수 있으며, 원치 않는 부작용을 초래할 수 있습니다.
4. **건축 및 컴퓨터 그래픽스**
건축 문헌에서의 규칙은 매우 강력하지만, 보통 추상적이고 과소 명시되어 있어 인간에 의해서만 적용될 수 있습니다. 우리의 형태 문법은 건축 개념을 적용하여 구체적인 형태 규칙을 도출하고, 고품질의 상세한 모델을 생성하는 데 성공했습니다. CGA Shape는 건축 설계보다는 컴퓨터 그래픽스에서 더 성공적으로 적용되었으며, 건축 설계에 적용하기 위해서는 추가적인 연구가 필요합니다.
5. **L-시스템과의 비교**
우리의 작업은 식물 모델링의 선구적인 작업에서 영감을 받았습니다. 유사점으로는 규칙 표기법, 범위 개념, 맥락 민감한 규칙의 필요성 등이 있습니다. 그러나 세부 사항과 모델링 과제는 근본적으로 다릅니다. 우리의 형태 문법은 문자열 대체보다는 형태 대체를 강조합니다. L-시스템을 건축에 직접 적용하면 성장 개념이 과도하게 강조되어, 건물 모델링에는 비생산적일 수 있습니다.
6. **인스턴트 아키텍처와의 비교**
우리의 형태 문법은 스플릿 규칙의 개념을 기반으로 하지만, 스플릿 문법의 엄격한 계층 구조를 더 이상 강제할 수 없습니다. 우리는 맥락 민감한 형태 규칙 모델과 일차원, 이차원, 삼차원 모델링의 상호작용을 우아하고 효율적인 솔루션으로 제안합니다.

### 한계와 향후 연구 과제

- **일관된 형태 생성의 어려움**: 절차적 접근 방식은 때때로 불가능한 형태 구성을 생성할 수 있습니다. 이러한 문제를 해결하기 위해 더 많은 연구가 필요합니다.
- **실시간 렌더링**: 대규모 도시 모델의 실시간 렌더링을 위해서는 추가적인 후처리 알고리즘과 레벨 오브 디테일(LOD) 기법이 필요합니다.

## 9 Conclusion

이 논문은 건물 외피의 절차적 모델링을 위한 새로운 형태 문법인 CGA Shape를 소개합니다. 주요 기여는 다음과 같습니다:

1. **건물의 부피 모델링과 지붕 설계**: 건물의 질량 모델링과 지붕 설계에 대한 새로운 접근 방식을 제시했습니다. 이 두 가지 요소는 논문의 주요 기여로, 건물 외피를 절차적으로 생성하는 데 있어 중요한 역할을 합니다.
2. **스플릿 문법의 확장**: 스플릿 문법의 여러 확장을 통해 복잡한 형태 구성과 상호작용을 모델링할 수 있는 완전한 시스템을 제공합니다. 이러한 확장은 다양한 건축 모델링 문제를 해결하는 데 유용합니다.
3. **대규모 도시 모델 생성**: CGA Shape는 Stiny의 형태 문법 아이디어를 컴퓨터 그래픽스에 성공적으로 적용하여, 산업 및 학계에서 생성된 기존 도시 모델보다 훨씬 더 많은 기하학적 세부 사항을 가진 거대한 도시 모델을 생성할 수 있습니다. 이는 도시 모델링의 효율성을 크게 향상시키며, 고품질의 세부 사항을 포함한 모델을 신속하게 생성할 수 있게 합니다.

결론적으로, CGA Shape는 절차적 모델링의 강력한 도구로서, 건물 외피와 대규모 도시 환경을 효율적으로 생성하는 데 큰 기여를 합니다. 향후 연구에서는 실시간 렌더링 및 일관된 형태 생성 문제를 해결하기 위한 추가적인 발전이 기대됩니다.