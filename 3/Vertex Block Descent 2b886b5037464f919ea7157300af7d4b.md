# Vertex Block Descent

[https://ankachan.github.io/Projects/VertexBlockDescent/index.html](https://ankachan.github.io/Projects/VertexBlockDescent/index.html)

[https://arxiv.org/pdf/2403.06321](https://arxiv.org/pdf/2403.06321)

[https://github.com/AnkaChan/TinyVBD](https://github.com/AnkaChan/TinyVBD)

- 2024 siggraph

![우리 솔버를 사용하여 시뮬레이션한 예제 결과로, 두 방법 모두 1억 이상의 자유도와 100만 개의 활성 충돌을 포함합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled.png)

우리 솔버를 사용하여 시뮬레이션한 예제 결과로, 두 방법 모두 1억 이상의 자유도와 100만 개의 활성 충돌을 포함합니다.

## 1 INTRODUCTION

물리 기반 시뮬레이션은 대부분의 그래픽 애플리케이션의 근간을 이루고 있으며, 시뮬레이션 시스템의 안정성, 계산 성능, 시각적 사실성을 향상시키기 위한 요구가 점점 커지고 있습니다. 특히 실시간 그래픽 애플리케이션에서는 안정성과 성능 요구 사항이 매우 엄격하여 사실성이 종종 부차적인 중요도로 간주될 수 있습니다.

지난 수십 년 동안 물리 솔버에 대한 상당한 연구와 획기적인 발견이 있었음에도 불구하고, 기존 방법들은 여전히 개선이 필요합니다. 이 방법들은 고품질 결과를 제공하지만 많은 애플리케이션의 계산 요구를 충족하지 못하거나 품질을 희생하여 주어진 계산 시간 내에 맞추려고 합니다. 특히 엄격한 계산 예산 내에서 안정성을 유지하는 것은 항상 도전 과제입니다.

이 논문에서는 이전 방법들보다 무조건적인 안정성, 우수한 계산 성능, 그리고 암시적 오일러 통합에 대한 수치적 수렴 능력을 제공하는 물리 솔버인 Vertex Block Descent(VBD)을 소개합니다. 이 방법은 다양한 시뮬레이션 문제에 사용할 수 있는 일반적인 솔루션이지만, 우리는 탄성체 동역학의 맥락에서 이를 제시하고 평가합니다. 또한 이 방법이 입자 기반 시뮬레이션 및 강체에도 어떻게 적용될 수 있는지 간략히 논의합니다.

VBD 방법은 암시적 오일러의 변분 형태를 해결하기 위해 정점 기반 가우스-자이델 반복을 수행하는 블록 좌표 하강을 기반으로 합니다. 탄성체 동역학의 경우, 각 반복은 메시 정점 위를 순회하며, 다른 모든 정점을 임시로 고정한 상태에서 단일 정점의 위치를 조정합니다. 이는 정점 기반 메시 색칠과 결합할 때 병렬성을 극대화할 수 있으며, 이는 요소 기반 병렬화에 비해 순차 작업이 훨씬 적은 색을 달성할 수 있습니다. 우리의 위치 기반 업데이트는 변분 에너지가 항상 감소하도록 보장할 수 있습니다. 따라서 이 방법은 큰 시간 단계와 단일 반복당 큰 잔류량을 포함하는 수렴되지 않은 솔루션으로도 안정성을 유지할 수 있으며, 더 많은 반복으로 대안보다 빠르게 수렴할 수 있습니다. 따라서 주어진 계산 예산에 더 쉽게 맞추면서 안정성을 유지하고 수렴성을 향상시킬 수 있습니다.

우리는 VBD를 탄성체 동역학에 사용하는 모든 필수 구성 요소를 제시하며, 댐핑, 제약, 충돌, 마찰에 대한 공식화를 포함합니다. 또한 초기화를 간단하게 시작하여 최적화를 워밍업하고 수렴성을 향상시키는 방법을 소개합니다. 또한 모멘텀 기반 가속 기술과 동적 충돌의 존재 하에서 병렬화에 대해 논의합니다. 우리의 평가에는 대규모 시뮬레이션과 VBD의 성능, 확장성, 안정성을 보여주는 스트레스 테스트가 포함됩니다.

![두 개의 빔을 함께 꼬는 시뮬레이션으로, 총 97,000개의 정점과 266,000개의 사면체를 포함하며 복잡한 마찰 접촉과 좌굴을 보여줍니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%201.png)

두 개의 빔을 함께 꼬는 시뮬레이션으로, 총 97,000개의 정점과 266,000개의 사면체를 포함하며 복잡한 마찰 접촉과 좌굴을 보여줍니다.

## 2 RELATED WORK

암시적 시간 적분기는 특히 경직된 문제를 다룰 때의 뛰어난 안정성 덕분에 컴퓨터 그래픽스에서 탄성체 시뮬레이션의 주요 방법으로 널리 받아들여지고 있습니다. 그중에서도 backward Euler 방법은 가장 흔히 사용되는 방식이며, implicit Newmark, BDF2, implicit-explicit 방법도 연구되었습니다. Backward Euler는 종종 단일 뉴턴 단계로 근사화되어 선형 방정식 시스템을 해결합니다. 선형 검색, 전처리, 양의 정부호 투영 등은 수렴을 개선하는 데 사용됩니다. 뉴턴 단계마다 전체 선형 해를 피하기 위해 Cholesky 분해도 사용됩니다. 다중 해상도나 다중 격자 해법은 세부 사항을 더 적은 자유도로 구성된 거친 격자로 투영하여 선형 시스템 해결의 계산 비용을 효과적으로 줄입니다. 우리의 해법은 힘을 국지적으로 선형화하여 전역 선형 시스템을 피하고, 여러 뉴턴 단계와 동일한 결과로 수렴합니다.

![극한 변형 상태에서 시뮬레이션을 시작하는 스트레스 테스트: (위) 15,000개의 정점과 50,000개의 사면체를 가진 완전히 납작한 아르마딜로 모델, (아래) 2,000개의 정점과 8,500개의 사면체를 가진 유타 티팟 모델의 정점들을 구 표면에 무작위로 배치한 변형. 두 모델 모두 시뮬레이션 시작 후 원래 형태로 빠르게 회복됩니다. 두 시뮬레이션 모두 𝜌 = 0.95로 가속된 반복을 사용합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%202.png)

극한 변형 상태에서 시뮬레이션을 시작하는 스트레스 테스트: (위) 15,000개의 정점과 50,000개의 사면체를 가진 완전히 납작한 아르마딜로 모델, (아래) 2,000개의 정점과 8,500개의 사면체를 가진 유타 티팟 모델의 정점들을 구 표면에 무작위로 배치한 변형. 두 모델 모두 시뮬레이션 시작 후 원래 형태로 빠르게 회복됩니다. 두 시뮬레이션 모두 𝜌 = 0.95로 가속된 반복을 사용합니다.

또한, stiffness warping은 원형 형태에서 강성 행렬을 재사용하여 큰 회전 변형을 처리합니다. 근사 헤시안을 사용하는 준-뉴턴 방법은 실제 헤시안보다 역을 계산하는 데 훨씬 비용 효율적입니다. 예제 기반 동역학에서는 변형 에너지를 예제 공간의 최근접점으로 정의합니다. Projective Dynamics는 변형 에너지를 일련의 제약 조건으로 나타내고, 이를 독립적으로 해결한 후 전역 단계를 통해 수렴을 가속화합니다.

동역학, 에너지, 최소화의 관계는 변분 적분기에서 활용되었습니다. backward Euler를 최적화 문제로 재구성하고 최적화 기술을 결합하여 큰 단계를 사용할 수 있게 합니다. 비선형 문제 해결을 위한 도메인 분할 최적화는 수렴을 가속화합니다. 그러나 최적화 공식화에는 각 단계의 문제 공식화와 초기 위치가 달라지는 단점이 있습니다. 따라서 일정한 시간 예산 내에서 일관된 수렴을 달성하는 것이 어렵습니다. 실시간 시뮬레이터는 부분적으로 수렴된 결과를 수용하여 시각적으로 최종 솔루션과 유사하게 보이도록 타협합니다. 그러나 이러한 타협은 이전 단계의 잔류물로 인해 누적되어 시뮬레이터의 안정성을 위협할 수 있습니다. 우리의 방법은 제한된 반복 수와 많은 잔류물을 유지하면서도 뛰어난 안정성을 보여줍니다.

위치 기반 동역학 방법(PBD와 XPBD)은 힘을 제약 조건으로 변환하고 가우스-자이델 반복으로 직접 위치를 업데이트하여 탁월한 안정성을 제공합니다. PBD와 유사하게, 우리의 방법도 위치 업데이트를 사용하지만, 제약 조건으로 변환하지 않고 힘 공식화를 직접 사용합니다. XPBD의 병렬화는 제약 조건을 그래프 색칠로 처리하지만, 이 이중 그래프는 더 많은 연결을 포함하여 병렬성을 제한합니다. 우리의 방법은 원래 그래프를 색칠하여 더 적은 색을 사용하고 병렬성을 향상시킵니다. 또한 XPBD의 근사치는 큰 시간 단계와 제한된 반복 수에서 사실성을 저하시킬 수 있습니다. 높은 질량 비율을 처리하는 데 XPBD가 어려움을 겪는 반면, 우리의 방법은 이러한 문제가 없습니다.

최근에는 GPU를 사용한 시뮬레이션 가속화 노력이 증가했습니다. 이 중 1차 하강법은 탁월한 병렬성으로 인기를 끌고 있습니다. 이러한 방법은 전체 정점 수준 병렬화를 가능하게 하는 Jacobi 스타일의 1차 하강을 사용하지만, 가우스-자이델 반복보다 느리게 수렴합니다. 우리의 방법은 최적화용 좌표 하강법으로 분류되며, 그래픽스에서는 지오메트릭 처리와 시뮬레이션에 사용되었습니다. 우리의 방법은 요소 기반 블록 대신 정점 기반 블록을 사용하여 더 나은 병렬성과 빠른 수렴을 제공합니다.

## 3 VERTEX BLOCK DESCENT FOR ELASTIC BODIES

우리의 Vertex Block Descent(VBD) 방법은 본질적으로 최적화 문제를 해결하기 위한 해법입니다. 따라서 다양한 시뮬레이션 문제에 적용할 수 있으며, 이 장에서는 탄성체 동역학의 맥락에서 이를 설명합니다. 우리는 질량을 지닌 정점 세트와 이들에 작용하는 힘 요소 및 제약 조건으로 표현된 객체에 대해 우리의 방법을 설명합니다. 다른 시뮬레이션 문제에 대한 일반화는 6장에서 논의됩니다.

먼저, 전체 시스템을 정점 수준의 지역 시스템으로 분할하는 글로벌 최적화 방법을 도출합니다. 그런 다음 지역 시스템을 해결하는 방법을 설명하고 댐핑, 제약 조건을 통합하는 방법을 다룹니다. 충돌 및 마찰에 대한 공식화, 최적화 수렴을 개선하는 초기화 방법, 모멘텀 기반 가속을 통해 수렴을 개선하는 방법을 제시합니다. 마지막으로, 동적으로 도입된 힘 요소의 병렬화를 효율적으로 수행하는 방법과 함께 병렬화 개선 방법을 논의합니다.

![두 가지 충돌 유형: (a) 에지-에지 충돌은 최대 두 쌍의 동일한 색상을 가질 수 있으며, (b) 정점-면 충돌은 동일한 색상을 가진 최대 한 쌍을 가질 수 있습니다. 이는 충돌의 동일한 쪽에 있는 정점은 다른 색상을 가져야 하기 때문입니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%203.png)

두 가지 충돌 유형: (a) 에지-에지 충돌은 최대 두 쌍의 동일한 색상을 가질 수 있으며, (b) 정점-면 충돌은 동일한 색상을 가진 최대 한 쌍을 가질 수 있습니다. 이는 충돌의 동일한 쪽에 있는 정점은 다른 색상을 가져야 하기 때문입니다.

### **글로벌 최적화**

VBD는 암시적 오일러 시간 적분의 최적화 형태를 기반으로 합니다. 𝑁개의 정점으로 구성된 시스템에서 시간 단계 𝑡에서 시뮬레이션 상태를 위치 벡터 𝑥𝑡와 속도 벡터 𝑣𝑡로 표현합니다. 다음 시간 단계의 위치를 평가하기 위한 최적화 문제는 변분 에너지를 최소화하는 것입니다. 이는 시스템을 정점 수준의 지역 시스템으로 분할하고 각 정점에서 변분 에너지를 최소화하여 해결됩니다.

각 정점의 지역 변분 에너지는 해당 정점에 작용하는 힘 요소에 의해 영향을 받습니다. 각 정점에서 다른 정점을 고정한 상태로 위치를 업데이트하여 글로벌 시스템을 가우스-자이델 반복으로 해결합니다. 이를 통해 전체 시스템 에너지가 감소하도록 보장하고, 안정적이고 효율적인 수렴을 달성합니다.

### **지역 시스템 해결**

각 정점의 위치 업데이트는 해당 정점의 지역 에너지를 최소화하는 것입니다. 이 과정은 작은 3D 선형 시스템을 해결하는 것으로 구성되며, 이는 전역 문제에 비해 평가 및 역행렬 계산 비용이 훨씬 저렴합니다. 우리는 뉴턴 방법을 사용하여 국소화된 에너지를 최소화하며, 이를 통해 시스템 에너지를 감소시키고 글로벌 시스템을 반복적으로 해결합니다.

뉴턴 단계는 선형 시스템을 해결하며, 이는 𝐺𝑖의 이차 근사치의 극점을 찾는 것입니다. 이 방법은 효율적이고 안정적이며, 필요에 따라 PSD 해시안 투영 또는 선형 검색을 사용하여 안정성을 추가로 확보할 수 있습니다. 그러나 우리의 실험에서는 이러한 기술 없이도 충분한 안정성을 유지했습니다.

### **댐핑**

댐핑은 시뮬레이션에서 과도한 진동을 방지하고 시스템 안정성을 향상시키는 데 중요한 역할을 합니다. 암시적 오일러 방법에 의해 수치적 댐핑이 도입되지만, 사용자에게 댐핑을 수동으로 제어할 수 있는 기능을 제공하는 것이 바람직합니다. 우리는 단순화된 레일리 댐핑 모델을 통합하여 이 작업을 수행합니다. 이 과정은 3×3 시스템 내에서 효율적으로 수행되며, 사전 계산된 강성 행렬을 사용합니다.

### **제약 조건**

VBD는 각 정점의 위치를 직접 조작하므로 정점에 대한 제약 조건을 관리하는 것이 간단합니다. 제약 조건은 일반적으로 일방적 또는 양방적으로 구분됩니다. 양방향 제약 조건의 경우, 특정 값을 설정하거나 선형 부분 공간에 제약됩니다. 일방향 제약 조건은 타협을 허용하고, 잠재 에너지를 다른 잠재 에너지와 함께 해결합니다. 우리의 방법은 시뮬레이션에서 월드 박스 제약을 처리합니다.

![동일한 높이에서 떨어뜨린 스윙 엘라스틱 진자의 서로 다른 초기화 옵션을 우리 방법으로 시뮬레이션한 결과입니다. 각 프레임당 20번의 반복만 사용한 시뮬레이션의 동일한 프레임을 보여줍니다. (a) 이전 위치와 (b) 관성을 사용하는 초기화는 중력 하에서 제대로 이동하지 못하는 반면, (c) 관성과 가속도를 사용하는 초기화는 수렴되지 않은 VBD에서 과도한 늘어짐을 초래합니다(빨간 선). (d) 우리의 적응형 솔루션은 (e) 완전히 수렴된 뉴턴 방법으로 생성된 기준(녹색 선)과 거의 일치합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%204.png)

동일한 높이에서 떨어뜨린 스윙 엘라스틱 진자의 서로 다른 초기화 옵션을 우리 방법으로 시뮬레이션한 결과입니다. 각 프레임당 20번의 반복만 사용한 시뮬레이션의 동일한 프레임을 보여줍니다. (a) 이전 위치와 (b) 관성을 사용하는 초기화는 중력 하에서 제대로 이동하지 못하는 반면, (c) 관성과 가속도를 사용하는 초기화는 수렴되지 않은 VBD에서 과도한 늘어짐을 초래합니다(빨간 선). (d) 우리의 적응형 솔루션은 (e) 완전히 수렴된 뉴턴 방법으로 생성된 기준(녹색 선)과 거의 일치합니다.

![엘라스틱 진자의 스윙 동안 적응형 초기화에 사용된 중력 비율 𝑎˜. 모델은 단일 조각 사면체 메시입니다. 자유 낙하 상태의 정점(빨간색)과 탄성이 중력에 대항하는 정점(파란색)을 자동으로 구분합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%205.png)

엘라스틱 진자의 스윙 동안 적응형 초기화에 사용된 중력 비율 𝑎˜. 모델은 단일 조각 사면체 메시입니다. 자유 낙하 상태의 정점(빨간색)과 탄성이 중력에 대항하는 정점(파란색)을 자동으로 구분합니다.

### **충돌**

충돌은 침투 깊이에 기반한 이차 충돌 에너지를 도입하여 처리됩니다. 충돌은 에지-에지 충돌과 정점-삼각형 충돌의 두 가지 유형으로 나뉩니다. 충돌 감지는 주기적으로 수행되며, 충돌 검출의 비용을 줄이기 위해 매 반복마다 CCD를 수행하지 않습니다. 검출된 충돌은 다음 충돌 감지까지 힘 요소로 유지됩니다.

### **마찰**

마찰은 접촉 지점의 상대 운동을 고려하여 계산됩니다. 우리는 점진적 잠재 접촉 마찰 모델을 사용하여 정적 마찰과 동적 마찰을 구분하며, 안정적인 마찰력 공식화를 위해 미분을 근사합니다. 이를 통해 마찰력과 그 도함수를 계산하여 정점의 힘과 해시안에 추가합니다.

### **초기화**

우리의 방법은 반복적 솔버이므로 초기 추정치를 설정하는 것이 중요합니다. 초기 추정치가 최종 위치에 가까울수록 수렴 속도가 빨라집니다. 우리는 관성 및 외부 가속도를 사용하여 적응형 초기화 방법을 제안합니다. 이는 정점이 자유 낙하와 유사한 움직임을 할 때 초기화를 포함하고, 정지 접촉 상태에서는 이전 위치를 유지하여 불필요한 관통을 방지합니다.

### **가속된 반복**

우리는 체비셰프 반-반복 방법을 사용하여 수렴을 개선합니다. 이 방법은 시스템의 스펙트럼 반경을 기반으로 가속 비율을 계산하며, 충돌이 발생한 정점에 대해서는 가속을 건너뛰어 안정성을 유지합니다.

![ 충돌이 많은 장면에서 가속기의 영향을 보여줍니다: 떨어지고 튀는 스퀴시 볼(230,000개의 정점, 700,000개의 사면체). (a)와 (b) 모두 ℎ = 1/120초를 사용하고, 시간 단계당 120번의 반복을 사용하며, 프레임당 평균 계산 시간은 0.11초입니다. (a) 가속 없이 120번의 반복은 불충분해 보입니다. (b) 우리 가속 방식(𝜌 = 0.95)은 충돌하는 정점을 건너뛰며 복잡한 충돌을 해결하여 훨씬 더 강한 결과에 대해 탄성 수렴을 눈에 띄게 향상시켜, (c) 2000번의 반복을 사용한 기준과 거의 일치합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%206.png)

 충돌이 많은 장면에서 가속기의 영향을 보여줍니다: 떨어지고 튀는 스퀴시 볼(230,000개의 정점, 700,000개의 사면체). (a)와 (b) 모두 ℎ = 1/120초를 사용하고, 시간 단계당 120번의 반복을 사용하며, 프레임당 평균 계산 시간은 0.11초입니다. (a) 가속 없이 120번의 반복은 불충분해 보입니다. (b) 우리 가속 방식(𝜌 = 0.95)은 충돌하는 정점을 건너뛰며 복잡한 충돌을 해결하여 훨씬 더 강한 결과에 대해 탄성 수렴을 눈에 띄게 향상시켜, (c) 2000번의 반복을 사용한 기준과 거의 일치합니다.

### **병렬화**

가우스-자이델 유형의 반복 방법은 그래프 색칠을 사용하여 병렬화됩니다. VBD는 정점을 색칠하여 일반적으로 더 적은 색을 사용하며, 동적으로 생성된 힘 요소를 효율적으로 병렬화하기 위해 보조 버퍼를 사용하여 레이스 조건을 방지합니다.

![정점 색칠 대 요소 색칠: (a) 정점 색칠은 10개의 정점에 대해 3개의 색이 필요하지만, (b) 요소 색칠(즉, 이중 그래프의 정점을 색칠하는 것)은 9개의 삼각형에 대해 7개의 색이 필요합니다. 이 차이는 사면체 메시에서 더 두드러집니다: (c) 우리의 정점 색칠은 3,891개의 정점에 대해 8개의 색만 사용하지만, (d) 우리의 요소 색칠 구현은 14,802개의 사면체에 대해 76개의 색이 필요합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%207.png)

정점 색칠 대 요소 색칠: (a) 정점 색칠은 10개의 정점에 대해 3개의 색이 필요하지만, (b) 요소 색칠(즉, 이중 그래프의 정점을 색칠하는 것)은 9개의 삼각형에 대해 7개의 색이 필요합니다. 이 차이는 사면체 메시에서 더 두드러집니다: (c) 우리의 정점 색칠은 3,891개의 정점에 대해 8개의 색만 사용하지만, (d) 우리의 요소 색칠 구현은 14,802개의 사면체에 대해 76개의 색이 필요합니다.

우리의 솔루션은 찢기 및 균열과 같은 다른 종류의 토폴로지 변경에도 적용될 수 있습니다. 힘 요소를 삭제할 때는 색칠을 변경할 필요가 없으며, 정점을 복제할 때는 원래 정점의 색을 상속할 수 있습니다.

![(a) 재색칠 없이 우리의 방식으로 충돌을 처리한 것과 (b) 완벽한 가우스-자이델 반복을 달성하기 위해 재색칠하여 처리한 것. 둘 다 마찰력을 사용하고 𝜌 = 0.95로 가속된 반복을 사용하여 시뮬레이션되었습니다. 결과는 거의 비슷하지만 동일하지는 않습니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%208.png)

(a) 재색칠 없이 우리의 방식으로 충돌을 처리한 것과 (b) 완벽한 가우스-자이델 반복을 달성하기 위해 재색칠하여 처리한 것. 둘 다 마찰력을 사용하고 𝜌 = 0.95로 가속된 반복을 사용하여 시뮬레이션되었습니다. 결과는 거의 비슷하지만 동일하지는 않습니다.

![ 2,500개의 정점과 4,800개의 삼각형으로 구성된 천 조각을 찢는 것.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%209.png)

 2,500개의 정점과 4,800개의 삼각형으로 구성된 천 조각을 찢는 것.

## 4 GPU IMPLEMENTATION

이 장에서는 VBD(Vertex Block Descent)를 현대 GPU의 병렬 처리 능력을 활용하여 구현하는 방법을 설명합니다. 현대 GPU는 블록 수준과 스레드 수준의 병렬 처리를 지원하는 계층적 구조를 가지고 있습니다. 블록 수준 병렬 처리는 각 블록이 독립적으로 작동하는 대규모 병렬 작업을 가능하게 하며, 스레드 수준 병렬 처리는 단일 명령어 다중 스레드(SIMT) 스타일 병렬 처리를 통해 블록 내 스레드 간 통신 및 동기화를 제공합니다.

### **VBD의 병렬화**

VBD는 이러한 계층적 아키텍처와 자연스럽게 일치합니다. 우리는 동일한 색상 범주 내에서 독립적으로 작동하는 수천 개의 정점을 가지고 있으며, 각 정점은 동시에 처리될 수 있는 여러 힘 요소와 연결됩니다. 이 장에서는 우리의 구현 알고리즘을 소개하며, 특히 각 정점을 블록 수준 병렬 처리하고, 블록 내 스레드가 힘과 해시안을 계산하여 지역 메모리에 저장하고, 이를 통해 합산하는 과정을 설명합니다.

### **알고리즘 구현**

알고리즘 1은 우리의 구현의 의사 코드를 보여줍니다. 각 정점을 처리하기 위해 블록 수준 병렬 처리를 사용합니다. 각 블록 내 스레드는 인접한 힘 요소의 힘과 해시안을 계산하고, 이를 로컬 공유 메모리에 저장한 후, 합산을 통해 최종 결과를 얻습니다. 각 블록은 고정된 수의 스레드를 사용하며, 인접한 힘 요소의 총 수가 각 블록의 스레드 수를 초과할 경우, 개별 스레드는 할당된 요소를 반복 처리합니다.

이 과정에서 공유 정점에 대한 글로벌 메모리 접근을 줄여 메모리 접근 패턴을 최적화합니다. 인접한 힘 요소가 다수의 정점을 공유하기 때문에, 동일한 블록 내 스레드가 이러한 공유 정점에 대한 글로벌 메모리 접근을 공유할 수 있습니다. 이 전략은 글로벌 메모리를 우회하고, 병렬적으로 힘과 해시안 값을 집계하여 전체 처리 효율성을 높입니다.

### **성능 향상**

우리의 실험에서, 정점당 단일 스레드를 사용하는 것에 비해 거의 10배의 성능 향상을 관찰했습니다. 주요 이점은 메모리 접근 패턴의 최적화에 있습니다. 이는 GPU 프로그램에서 일반적인 병목 현상으로, 이 구현은 블록 내 메모리 발산을 줄이고, 병렬 평가를 통해 로컬 메모리에 집계하여 병렬성을 최적화합니다.

### **결론**

GPU 구현을 통해 VBD는 병렬 처리의 효율성을 극대화하여 성능을 크게 향상시킵니다. 이 장에서는 VBD의 병렬화 방법과 그에 따른 성능 향상에 대해 논의하였습니다. 우리의 GPU 기반 VBD 구현은 다양한 복잡한 시뮬레이션 시나리오에서 빠르고 안정적인 성능을 제공합니다.

## 5 RESULTS

이 장에서는 VBD(Vertex Block Descent) 방법을 사용하여 수행한 다양한 시뮬레이션 테스트와 그 결과를 설명합니다. 우리는 대규모 테스트, 단위 테스트, 스트레스 테스트를 통해 VBD의 성능, 안정성 및 수렴 속도를 평가하고, 다른 대체 방법과의 비교를 통해 VBD의 장점을 강조합니다.

### **5.1 대규모 테스트**

대규모 테스트에서는 복잡한 충돌을 포함한 시나리오에서 VBD의 성능, 확장성 및 안정성을 보여줍니다. 예를 들어, 216개의 스퀴시 볼과 10,000개 이상의 변형 가능한 객체가 포함된 시뮬레이션을 수행하여 VBD의 뛰어난 병렬 처리와 빠른 수렴 속도를 입증했습니다. 각 프레임당 평균 계산 시간은 각각 40초와 25초였습니다.

![촉수가 있는 216개의 스퀴시 볼을 유타 티팟에 떨어뜨려 안정적인 더미를 형성하는 시뮬레이션, 총 4,800만 개의 정점과 1억 5천 1백만 개의 사면체로 구성되어 있으며, 활성 마찰 접촉이 있습니다. 프레임당 𝑆 = 4 하위 단계와 단계당 𝑛max = 40 반복을 사용하여 평균 및 최대 계산 시간은 각각 3.6초와 3.9초입니다. 이 시뮬레이션의 최종 프레임은 그림 1에 나와 있습니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2010.png)

촉수가 있는 216개의 스퀴시 볼을 유타 티팟에 떨어뜨려 안정적인 더미를 형성하는 시뮬레이션, 총 4,800만 개의 정점과 1억 5천 1백만 개의 사면체로 구성되어 있으며, 활성 마찰 접촉이 있습니다. 프레임당 𝑆 = 4 하위 단계와 단계당 𝑛max = 40 반복을 사용하여 평균 및 최대 계산 시간은 각각 3.6초와 3.9초입니다. 이 시뮬레이션의 최종 프레임은 그림 1에 나와 있습니다.

![10,368개의 변형 가능한 객체를 상자 내부의 플랫폼 위에 떨어뜨리는 시뮬레이션, 총 3,600만 개 이상의 정점과 1억 2천 4백만 개의 사면체로 구성되어 있습니다. 그런 다음 플랫폼을 갑자기 제거하여 객체들이 집단적으로 바닥에 떨어져 플랫폼이 제거되기 전과 후에 안정적인 더미를 형성합니다. 프레임당 𝑆 = 2 하위 단계와 단계당 𝑛max = 60 반복을 사용하여 평균 및 최대 계산 시간은 각각 4.2초와 4.7초입니다. 이 시뮬레이션의 최종 프레임은 그림 1에 나와 있습니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2011.png)

10,368개의 변형 가능한 객체를 상자 내부의 플랫폼 위에 떨어뜨리는 시뮬레이션, 총 3,600만 개 이상의 정점과 1억 2천 4백만 개의 사면체로 구성되어 있습니다. 그런 다음 플랫폼을 갑자기 제거하여 객체들이 집단적으로 바닥에 떨어져 플랫폼이 제거되기 전과 후에 안정적인 더미를 형성합니다. 프레임당 𝑆 = 2 하위 단계와 단계당 𝑛max = 60 반복을 사용하여 평균 및 최대 계산 시간은 각각 4.2초와 4.7초입니다. 이 시뮬레이션의 최종 프레임은 그림 1에 나와 있습니다.

### **5.2 단위 테스트**

VBD의 수렴 속도는 시뮬레이션 시스템의 강성에 따라 달라집니다. 다양한 강성의 재료에 대해 VBD를 테스트한 결과, 더 부드러운 재료는 적은 반복 횟수로도 충분히 수렴하는 반면, 강성이 높은 재료는 더 많은 반복이 필요함을 확인했습니다. 마찰 계수 및 댐핑 강도를 조절하여 시뮬레이션 결과를 비교하고, 각 변수의 영향을 시각적으로 확인했습니다.

![다양한 재료 강성에 대한 프레임당 반복 횟수에 따른 시각적 수렴(𝜌 = 0.75, 0.86, 0.93 사용), 463개의 정점과 1,500개의 사면체를 가진 빔을 시뮬레이션합니다](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2012.png)

다양한 재료 강성에 대한 프레임당 반복 횟수에 따른 시각적 수렴(𝜌 = 0.75, 0.86, 0.93 사용), 463개의 정점과 1,500개의 사면체를 가진 빔을 시뮬레이션합니다

### **5.3 스트레스 테스트**

VBD의 안정성을 극한 상황에서 테스트한 결과를 제시합니다. 두 개의 얇은 빔을 꼬는 예제나, 모델을 납작하게 누르거나 무작위로 흩뿌린 상태에서 시뮬레이션하여 VBD가 극한 변형과 충돌 상황에서도 안정적으로 동작함을 확인했습니다. 이러한 스트레스 테스트는 VBD가 제한된 반복 횟수와 많은 잔류량을 유지하면서도 안정성을 유지할 수 있음을 보여줍니다.

![(위) 경사면에 처음에 놓여 있는 400개의 정점과 1,450개의 사면체를 가진 탄성 큐브와 (아래) 상자에 떨어뜨린 총 15,600개의 정점과 6만 개의 사면체를 가진 4개의 탄성 문어 모델에 대해 다양한 마찰 계수 𝜇𝑐를 테스트합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2013.png)

(위) 경사면에 처음에 놓여 있는 400개의 정점과 1,450개의 사면체를 가진 탄성 큐브와 (아래) 상자에 떨어뜨린 총 15,600개의 정점과 6만 개의 사면체를 가진 4개의 탄성 문어 모델에 대해 다양한 마찰 계수 𝜇𝑐를 테스트합니다.

![극한의 늘어짐을 가진 스트레스 테스트: 1,800개의 정점과 5,900개의 사면체를 가진 스탠포드 토끼 모델이 천천히 10개의 정점을 당겨서 늘어납니다. 그런 다음 갑자기 해제됩니다. 모델은 상당한 변형과 고속 운동을 거친 후 원래 형태로 회복됩니다. 자체 충돌을 사용하여 시뮬레이션하고, 프레임당 𝑆 = 5 하위 단계와 단계당 𝑛max = 10 반복을 사용합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2014.png)

극한의 늘어짐을 가진 스트레스 테스트: 1,800개의 정점과 5,900개의 사면체를 가진 스탠포드 토끼 모델이 천천히 10개의 정점을 당겨서 늘어납니다. 그런 다음 갑자기 해제됩니다. 모델은 상당한 변형과 고속 운동을 거친 후 원래 형태로 회복됩니다. 자체 충돌을 사용하여 시뮬레이션하고, 프레임당 𝑆 = 5 하위 단계와 단계당 𝑛max = 10 반복을 사용합니다.

### **5.4 수렴 속도**

VBD의 수렴 속도를 다른 방법들과 비교한 결과를 제시합니다. 예를 들어, 사전 조건화된 경사 하강법(GD)과 뉴턴 방법, 블록 자코비 방법과 비교한 결과, VBD가 반복당 수렴 속도가 더 빠르고 효율적임을 확인했습니다. 특히 가속된 VBD는 다른 방법들에 비해 수렴 속도에서 큰 차이를 보였습니다.

![프레임당 단일 반복만 사용하는 스트레스 테스트(즉, 시간 단계 ℎ = 1/60초와 𝑛max = 1). 아르마딜로 모델의 코에 있는 한 정점을 당기고, 손가락과 발가락 정점을 고정합니다. 모델은 15,000개의 정점과 50,000개의 사면체로 구성되어 있습니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2015.png)

프레임당 단일 반복만 사용하는 스트레스 테스트(즉, 시간 단계 ℎ = 1/60초와 𝑛max = 1). 아르마딜로 모델의 코에 있는 한 정점을 당기고, 손가락과 발가락 정점을 고정합니다. 모델은 15,000개의 정점과 50,000개의 사면체로 구성되어 있습니다.

### **5.5 XPBD와의 비교**

우리의 방법과 XPBD(Position-Based Dynamics) 방법을 직접 비교하여 중요한 차이점을 강조합니다. 예를 들어, 복잡한 충돌이 많은 시나리오에서 XPBD는 VBD에 비해 안정성이 떨어지며, 큰 시간 단계에서 현실감이 저하될 수 있습니다. 또한 XPBD는 높은 질량 비율을 처리하는 데 어려움을 겪지만, VBD는 이러한 문제 없이 안정적으로 작동합니다.

![상대적으로 부드러운 재료(위)와 10배 더 강한 재료(아래)를 사용하여 15,000개의 정점과 50,000개의 사면체를 가진 아르마딜로 모델을 시뮬레이션하는 다양한 하강 방법의 수렴. 유리 블록 안의 상단 근처에 있는 정점이 고정되어 있으며, 모델은 초기에는 발 정점을 아래로 당겨 늘려져 있습니다. 그런 다음 발 정점의 위치 제약 조건이 갑자기 제거되어 모델이 33ms 동안 변형됩니다. 변형은 ℎ = 33ms의 단일 시간 단계로 계산됩니다. 그래프는 반복 횟수와 계산 시간에 따른 상대적 손실을 보여줍니다. 모든 방법은 단일 정밀도(32비트) 부동 소수점 숫자를 사용하여 동일한 프레임워크에서 GPU로 구현되었으며, 뉴턴 방법은 Cholesky 분해를 사용하여 CPU에서 이중 정밀도(64비트)로 실행됩니다. 가속된 버전은 𝜌 = 0.95를 사용합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2016.png)

상대적으로 부드러운 재료(위)와 10배 더 강한 재료(아래)를 사용하여 15,000개의 정점과 50,000개의 사면체를 가진 아르마딜로 모델을 시뮬레이션하는 다양한 하강 방법의 수렴. 유리 블록 안의 상단 근처에 있는 정점이 고정되어 있으며, 모델은 초기에는 발 정점을 아래로 당겨 늘려져 있습니다. 그런 다음 발 정점의 위치 제약 조건이 갑자기 제거되어 모델이 33ms 동안 변형됩니다. 변형은 ℎ = 33ms의 단일 시간 단계로 계산됩니다. 그래프는 반복 횟수와 계산 시간에 따른 상대적 손실을 보여줍니다. 모든 방법은 단일 정밀도(32비트) 부동 소수점 숫자를 사용하여 동일한 프레임워크에서 GPU로 구현되었으며, 뉴턴 방법은 Cholesky 분해를 사용하여 CPU에서 이중 정밀도(64비트)로 실행됩니다. 가속된 버전은 𝜌 = 0.95를 사용합니다.

### **결론**

이 장에서는 VBD의 성능, 안정성 및 수렴 속도를 다양한 테스트를 통해 평가하고, 다른 방법들과의 비교를 통해 VBD의 장점을 강조했습니다. VBD는 복잡한 시뮬레이션 시나리오에서 빠르고 안정적인 성능을 제공하며, 다양한 상황에서 우수한 결과를 보여줍니다.

## 6 VBD FOR OTHER SIMULATION SYSTEMS

이 장에서는 VBD(Vertex Block Descent) 방법이 탄성체 동역학 외에도 다른 시뮬레이션 시스템에 어떻게 적용될 수 있는지 논의합니다. 여기서 다루는 예제들은 입자 기반 시뮬레이션, 강체 시뮬레이션, 그리고 통합 시뮬레이션 시스템입니다.

![ 단일 스레드 CPU 구현과 단일 스레드 뉴턴 방법(CG 및 Cholesky 사용)을 비교합니다. 장면은 그림 17의 하단과 동일합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2017.png)

 단일 스레드 CPU 구현과 단일 스레드 뉴턴 방법(CG 및 Cholesky 사용)을 비교합니다. 장면은 그림 17의 하단과 동일합니다.

![ 230,000개의 정점과 700,000개의 사면체로 구성된 촉수가 있는 스퀴시 볼을 바닥에 떨어뜨린 시뮬레이션, (a) 큰 시간 단계와 프레임당 240번의 반복을 사용한 XPBD, (b) 25배 작은 시간 단계와 프레임당 총 250번의 반복을 사용한 XPBD, (c) 동일한 작은 시간 단계와 반복 횟수를 사용하지만 25배 더 빈번한 충돌 감지를 사용하는 XPBD, (d) 큰 시간 단계와 프레임당 240번의 반복을 사용한 VBD. (a)와 (d)를 비교할 때 VBD는 동일한 설정에서 XPBD보다 빠릅니다. 시간 단계가 감소함에 따라 XPBD의 솔루션은 VBD에 접근하지만, VBD와 비슷한 시각적 결과를 얻으려면 더 빈번한 충돌 감지가 필요합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2018.png)

 230,000개의 정점과 700,000개의 사면체로 구성된 촉수가 있는 스퀴시 볼을 바닥에 떨어뜨린 시뮬레이션, (a) 큰 시간 단계와 프레임당 240번의 반복을 사용한 XPBD, (b) 25배 작은 시간 단계와 프레임당 총 250번의 반복을 사용한 XPBD, (c) 동일한 작은 시간 단계와 반복 횟수를 사용하지만 25배 더 빈번한 충돌 감지를 사용하는 XPBD, (d) 큰 시간 단계와 프레임당 240번의 반복을 사용한 VBD. (a)와 (d)를 비교할 때 VBD는 동일한 설정에서 XPBD보다 빠릅니다. 시간 단계가 감소함에 따라 XPBD의 솔루션은 VBD에 접근하지만, VBD와 비슷한 시각적 결과를 얻으려면 더 빈번한 충돌 감지가 필요합니다.

![질량 비율이 1:2000인 큰 무거운 탄성 큐브를 더 작고 가벼운 상자 위에 떨어뜨립니다. 각 큐브는 400개의 정점과 1,500개의 사면체를 가지고 있습니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2019.png)

질량 비율이 1:2000인 큰 무거운 탄성 큐브를 더 작고 가벼운 상자 위에 떨어뜨립니다. 각 큐브는 400개의 정점과 1,500개의 사면체를 가지고 있습니다.

![스프링으로 연결된 20개의 입자가 스윙 체인을 형성하며, 𝑆 = 1 하위 단계와 단계당 100번의 반복을 사용하여 VBD로 시뮬레이션됩니다. 체인의 한쪽 끝 입자는 고정되어 있으며, 다른 쪽 끝 입자는 다른 입자보다 1000배 더 무겁습니다. (왼쪽) 충분히 강한 스프링을 사용하면 상당한 질량 차이에도 불구하고, 스프링은 원래 길이의 0.7% 이상 확장되지 않습니다. (오른쪽) 100배 덜 강한 스프링을 사용하면 체인이 스윙하면서 눈에 띄게 확장됩니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2020.png)

스프링으로 연결된 20개의 입자가 스윙 체인을 형성하며, 𝑆 = 1 하위 단계와 단계당 100번의 반복을 사용하여 VBD로 시뮬레이션됩니다. 체인의 한쪽 끝 입자는 고정되어 있으며, 다른 쪽 끝 입자는 다른 입자보다 1000배 더 무겁습니다. (왼쪽) 충분히 강한 스프링을 사용하면 상당한 질량 차이에도 불구하고, 스프링은 원래 길이의 0.7% 이상 확장되지 않습니다. (오른쪽) 100배 덜 강한 스프링을 사용하면 체인이 스윙하면서 눈에 띄게 확장됩니다.

### **6.1 입자 기반 시뮬레이션**

입자 기반 시뮬레이션에서는 VBD를 사용하여 정점을 입자로 대체할 수 있습니다. 이를 통해 각 입자에 작용하는 모든 힘에 대한 도함수를 계산하여 힘 요소 에너지를 최소화할 수 있습니다. 병렬화는 정점 색칠 기법을 사용하여 병렬화할 수 있습니다. 이 경우 동적으로 변경되는 입자 상호작용을 고려하여 보수적인 이웃 정의를 사용하여 색칠해야 합니다. 예를 들어, 20개의 입자와 하나의 무거운 입자가 스프링으로 연결된 단순한 예제를 통해 VBD를 적용할 수 있습니다.

### **6.2 강체 시뮬레이션**

강체 시뮬레이션에서 VBD를 적용하려면 정점을 강체로 대체합니다. 강체는 회전 자유도를 포함하여 6개의 자유도를 가지므로, 각 정점의 국소 시스템은 6×6 행렬을 포함해야 합니다. 강체에 작용하는 외부 힘 요소를 포함한 해시안을 계산하여 지역 에너지를 최소화합니다. 병렬화는 강체 체인과 같은 문제에 대해 사전 색칠을 사용하거나, 충돌과 같은 동적 힘 요소에 대해 동적 색칠을 사용할 수 있습니다. 예를 들어, VBD를 사용한 강체 시뮬레이션의 예제를 통해 이러한 방법을 시연할 수 있습니다.

![충돌을 통해 체인을 형성하는 5개의 강체, 각각 6개의 자유도를 가지며, VBD 공식을 사용하여 강체 동역학을 시뮬레이션합니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2021.png)

충돌을 통해 체인을 형성하는 5개의 강체, 각각 6개의 자유도를 가지며, VBD 공식을 사용하여 강체 동역학을 시뮬레이션합니다.

![유타 티팟에 60개의 강체를 떨어뜨려 충돌과 마찰 접촉을 보여줍니다. 놀랍게도 한 강체가 마찰로 인해 주둥이에 남아 있습니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2022.png)

유타 티팟에 60개의 강체를 떨어뜨려 충돌과 마찰 접촉을 보여줍니다. 놀랍게도 한 강체가 마찰로 인해 주둥이에 남아 있습니다.

### **6.3 통합 시뮬레이션 시스템**

통합 시뮬레이션 시스템은 다양한 물질 유형을 처리하는 데 유용합니다. VBD는 모든 물질을 동일한 기본 블록으로 표현하지 않고도 통합 시뮬레이션 시스템을 형성할 수 있습니다. 예를 들어, 충돌 상호작용을 통해 강체와 탄성체 또는 입자 시스템을 결합할 수 있습니다. 조인트 제약 조건을 사용하여 다른 시뮬레이션 시스템을 결합할 수 있습니다. 이러한 통합 시뮬레이션 시스템은 다양한 표현 방식이 동일한 통합기 내에서 VBD를 사용하여 결합될 수 있음을 보여줍니다.

다른 유형의 정보 교환, 예를 들어 부력 평가와 같은 문제를 정의하는 것은 도전 과제가 될 수 있으며, 이는 향후 연구의 흥미로운 방향이 될 것입니다.

### **결론**

VBD는 다양한 시뮬레이션 시스템에 적용될 수 있는 일반적인 해법으로, 입자 시스템, 강체, 통합 시뮬레이션 등 다양한 문제에 유연하게 적용할 수 있습니다. 이 장에서는 VBD를 다른 시뮬레이션 시스템에 적용하는 방법과 그 가능성을 논의했습니다.

## 7 DISCUSSION

VBD(Vertex Block Descent)는 변분 시간 적분기의 블록 좌표 하강 방법으로 도출되었으며, PSD 투영 및 선형 검색과 같은 최적화 기술을 제공할 수 있습니다. 이러한 기술 없이도 안정성을 보장할 수 있는 VBD는 비선형 방정식의 일반적인 솔루버 역할을 합니다. 비보존력을 효율적으로 처리하며, 최적화 관점에서 파생된 기술을 사용하지 않더라도 높은 성능을 유지할 수 있습니다.

![부드러운 스프링(주황색)과 10,000배 더 강한 스프링(파란색)으로 연결된 입자 체인. (a, c) 프레임당 100번의 반복을 사용한 VBD 시뮬레이션은 수렴에 실패하여 과도한 확장을 초래합니다. (b, d) 수렴된 결과와 비교됩니다.](Vertex%20Block%20Descent%202b886b5037464f919ea7157300af7d4b/Untitled%2023.png)

부드러운 스프링(주황색)과 10,000배 더 강한 스프링(파란색)으로 연결된 입자 체인. (a, c) 프레임당 100번의 반복을 사용한 VBD 시뮬레이션은 수렴에 실패하여 과도한 확장을 초래합니다. (b, d) 수렴된 결과와 비교됩니다.

VBD는 지역 반복을 통해 작동하는 하강 기반 방법이므로 전역 처리가 필요한 문제에는 적합하지 않을 수 있습니다. 정보 전달 속도는 정점 간 연결과 반복 횟수에 따라 달라지므로, 고해상도 강직 시스템에는 많은 반복이 필요할 수 있습니다. 이러한 경우, 뉴턴 방법과 같은 전역 솔루션이 더 효과적일 수 있습니다.

VBD의 충돌 공식은 침투 잠재력을 기반으로 하므로, 완전히 무침투 상태를 보장하지는 않습니다. 약간의 침투가 충돌력을 유지하는 데 필요하며, 코디멘셔널 객체의 충돌 에너지를 정의하는 것은 도전 과제가 될 수 있습니다.

VBD는 본질적으로 프라이멀 솔버로, 높은 질량 비율을 쉽게 처리할 수 있지만, 높은 강성 비율에서는 수렴이 어렵습니다. 예를 들어, 1:10000의 강성 비율을 가진 경우 VBD의 수렴 속도가 느려질 수 있습니다.

## 8 CONCLUSION

VBD는 효율적이고 안정적인 반복 기반 솔루션으로, 암시적 오일러 통합을 변분 공식으로 정의한 물리 기반 시뮬레이션에 적합합니다. 이 논문에서는 VBD를 탄성체 동역학에 적용하는 모든 필수 구성 요소를 설명하고, 댐핑, 제약, 충돌, 마찰을 다루는 방법을 제시했습니다. 적응형 초기화 기술을 정의하고, 수렴을 개선하기 위한 모멘텀 기반 가속 방법을 논의했습니다. 또한, 동적으로 도입 및 제거되는 힘 요소를 고려하여 병렬화를 수행하는 방법을 제시했습니다.

우리의 결과는 VBD가 매우 복잡한 시뮬레이션 사례를 처리할 수 있음을 보여주었으며, 극한 스트레스 테스트에서도 안정적으로 작동함을 입증했습니다. 또한, VBD의 빠른 수렴 속도를 통해 다양한 시뮬레이션 문제에 유연하게 적용할 수 있음을 확인했습니다.

VBD는 입자 시스템, 강체, 통합 시뮬레이션 등 다양한 시뮬레이션 문제에 적용될 수 있는 일반적인 해법으로서, 향후 연구 방향과 한계점을 고려한 잠재적 응용 가능성을 제시합니다.