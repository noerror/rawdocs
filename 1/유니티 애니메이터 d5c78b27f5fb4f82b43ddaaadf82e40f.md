# 유니티 애니메이터

애니메이션과 애니메이터는 유니티에서 캐릭터나 객체에 움직임을 부여하는 데 중요한 역할을 합니다. 이 두 용어에 대해 각각 설명하겠습니다.

1. **애니메이션(Animation)**:
    - 유니티에서 애니메이션은 객체의 속성(위치, 회전, 스케일 등)이 시간에 따라 어떻게 변화하는지를 정의합니다.
    - 애니메이션 클립(Animation Clip)은 특정 동작이나 일련의 움직임을 저장한 파일입니다. 예를 들어, 캐릭터가 걷거나 뛰는 동작을 애니메이션 클립으로 만들 수 있습니다.
    - 이 클립들은 키 프레임(Keyframe)을 사용하여 각 시점에서의 객체 상태를 정의하며, 유니티는 이 키 프레임들 사이를 보간하여 부드러운 움직임을 생성합니다.
2. **애니메이터(Animator)**:
    - 애니메이터 컴포넌트는 애니메이션 클립을 관리하고 제어하는 역할을 합니다.
    - 애니메이터는 애니메이터 컨트롤러(Animator Controller)를 통해 여러 애니메이션 클립을 조합하고, 상황에 따라 적절한 애니메이션을 재생할 수 있도록 합니다.
    - 애니메이터 컨트롤러 내에서는 스테이트(State)와 트랜지션(Transition)을 사용하여 애니메이션 간의 전환을 설정합니다. 예를 들어, 캐릭터가 걷는 상태에서 뛰는 상태로 변화할 때 어떤 애니메이션 클립을 재생할지 결정할 수 있습니다.
    - 또한, 파라미터(Parameter)를 설정하여 코드에서 애니메이션의 흐름을 제어할 수 있습니다. 예를 들어, 속도라는 파라미터에 따라 걷기와 뛰기 애니메이션을 전환할 수 있습니다.

유니티의 애니메이션 시스템을 사용하면 복잡한 캐릭터의 동작과 상호작용을 효과적으로 구현할 수 있으며, 게임의 시각적 매력과 실감 나는 움직임을 제공할 수 있습니다. 이 시스템은 게임 개발에서 매우 중요한 부분을 차지합니다.

## 애니메이션 클립 (Animation)

### **스프라이트 애니메이션 제어 가능한 속성들**

1. **Visibility (가시성)**:
    - 스프라이트의 가시성은 애니메이션을 통해 제어할 수 있습니다. 예를 들어, 스프라이트의 **`Renderer`** 컴포넌트의 **`enabled`** 속성을 키 프레임을 사용해 켜고 끌 수 있습니다. 이를 통해 캐릭터가 특정 동작을 할 때만 스프라이트가 보이도록 설정할 수 있습니다.
2. **Transform (변형)**:
    - 위치, 회전, 크기(scale) 등의 변형 속성들은 애니메이션 클립 내에서 키 프레임을 통해 제어됩니다. 각 키 프레임은 특정 시점에서의 속성 값을 저장하며, 유니티 엔진이 이 값을 시간에 따라 자동으로 보간하여 부드러운 변화를 생성합니다.
3. **Color (색상)**:
    - 스프라이트의 색상 변경도 애니메이션을 통해 가능합니다. 스프라이트 렌더러의 **`color`** 속성을 조정함으로써, 시간에 따라 색상을 변화시킬 수 있습니다. 이는 특히 피격 시 캐릭터가 붉게 변하는 등의 효과를 구현할 때 유용합니다.

### **값의 보간 (Interpolation)**

애니메이션에서 키 프레임 사이의 값을 계산하는 방법을 보간이라고 합니다. 보간은 애니메이션을 부드럽게 만들기 위해 중간 값을 자동으로 생성하는 과정입니다.

1. **선형 보간 (Linear Interpolation)**:
    - 가장 간단한 형태의 보간 방식으로, 두 키 프레임 값 사이를 직선적으로 연결합니다. 시간이 균등하게 흐르는 동안 속성 값도 균등하게 변화합니다.
2. **곡선 보간 (Curved Interpolation)**:
    - 더 부드러운 애니메이션을 위해 곡선을 사용하여 보간합니다. 유니티의 애니메이션 에디터에서는 키 프레임 간의 곡선을 조절할 수 있는 핸들을 제공하여, 움직임의 가속도나 감속을 미세 조정할 수 있습니다.
3. **스플라인 보간 (Spline Interpolation)**:
    - 복잡한 경로나 형태를 표현할 때 사용되며, 여러 키 프레임을 부드럽게 연결하는 데 적합합니다. 스플라인은 특히 자연스러운 움직임이 필요한 경우에 유용합니다.

유니티에서 이러한 보간 방식을 적절히 활용하면, 게임 내 객체의 움직임을 자연스럽고 생동감 있게 표현할 수 있습니다. 애니메이터 컨트롤러와 애니메이션 클립을 통해 다양한 속성을 섬세하게 조절하면서 풍부한 시각적 효과를 구현할 수 있습니다.

유니티에서 애니메이션 채널은 애니메이션 클립 내에서 특정 객체의 특정 속성에 대한 애니메이션 데이터를 포함하고 있습니다. 이 채널 정보는 실제로 객체의 이름을 기반으로 연결됩니다. 이는 애니메이션 시스템이 해당 객체의 이름을 참조하여 애니메이션을 적용하므로, 객체의 이름이나 그 계층 구조가 변경되면 애니메이션 적용에 문제가 발생할 수 있습니다.

### **애니메이션 채널 정보와 객체 이름**

애니메이션 클립에 저장된 각 애니메이션 채널은 특정 객체를 지정하며, 이는 유니티 에디터 내에서 해당 객체의 이름으로 식별됩니다. 예를 들어, "Player"라는 이름의 객체에 대해 위치와 회전을 조절하는 애니메이션 클립이 있다면, 이 클립은 "Player"라는 이름의 객체를 찾아 그 속성을 애니메이션합니다.

### **이름이나 계층 변경 시의 문제점**

1. **이름 변경**: 객체의 이름을 변경하면, 기존의 애니메이션 클립은 더 이상 해당 객체를 식별할 수 없게 됩니다. 예를 들어, "Player" 객체의 이름을 "Hero"로 변경하면, 원래 "Player"에 적용되었던 애니메이션 클립은 "Hero"를 찾지 못하고, 결과적으로 애니메이션은 재생되지 않습니다.
2. **계층 변경**: 유니티에서 객체의 계층 구조를 변경하는 것도 유사한 문제를 일으킬 수 있습니다. 객체를 다른 부모 아래로 이동하면, 경로가 변경됩니다. 예를 들어, "Player" 객체가 "Characters"의 자식에서 "Enemies"의 자식으로 이동하면, 애니메이션 클립이 올바르게 참조하지 못할 수 있습니다.

### **해결 방법**

- **애니메이션 클립 수정**: 이름이나 계층이 변경된 후에는 애니메이션 클립을 열고 새로운 객체 이름이나 계층 구조에 맞게 수정해야 합니다. 유니티 애니메이션 에디터에서는 이러한 수정이 비교적 간단하게 이루어질 수 있습니다.
- **이름 및 계층 구조의 일관성 유지**: 프로젝트 개발 초기 단계에서 객체의 이름과 계층 구조를 신중하게 계획하고, 이를 가능한 변경하지 않도록 관리하는 것이 중요합니다.

애니메이션과 객체의 이름 및 계층 구조 간의 연결성을 이해하는 것은 유니티에서 안정적이고 효율적인 애니메이션 작업을 위해 매우 중요합니다. 이를 통해 게임 개발 과정에서 발생할 수 있는 여러 문제들을 예방할 수 있습니다.

## 애니메이터 (Animator)

유니티에서 초기에는 **`Animation`** 컴포넌트를 통해 직접 애니메이션 클립을 재생하는 방식을 사용했습니다. 이 방식은 간단하고 직관적이지만, 복잡한 애니메이션 시퀀스나 다양한 애니메이션 상태 간의 전환을 효과적으로 관리하는 데에는 한계가 있었습니다. 이러한 이유로 유니티는 보다 고급 기능을 제공하는 **`Animator`** 컴포넌트와 애니메이터 컨트롤러 방식으로 전환하게 되었습니다. 이 변경의 주된 이유와 장점을 몇 가지로 요약해 보겠습니다.

### **1. 애니메이션 상태 관리**

- **기존 방식**: **`Animation`** 컴포넌트에서는 여러 애니메이션 클립을 동시에 관리하거나, 상태에 따라 애니메이션을 스무스하게 전환하는 것이 어려웠습니다.
- **새로운 방식**: **`Animator`** 컴포넌트는 애니메이터 컨트롤러를 사용하여 다양한 애니메이션 상태(State)와 그 사이의 전환(Transition)을 시각적으로 쉽게 구성할 수 있게 해줍니다. 이를 통해 개발자는 복잡한 애니메이션 로직을 효율적으로 관리할 수 있습니다.

### **2. 조건부 로직 통합**

- **기존 방식**: 코드 내에서 직접 애니메이션 클립을 조건에 따라 제어해야 했습니다.
- **새로운 방식**: **`Animator`** 컴포넌트는 파라미터(Parameter)를 기반으로 한 조건부 로직을 지원합니다. 예를 들어, 캐릭터의 속도나 상태에 따라 자동으로 애니메이션을 전환할 수 있습니다.

### **3. 블렌딩과 레이어링**

- **기존 방식**: 두 애니메이션 클립 사이의 부드러운 전환(블렌딩)이나, 여러 애니메이션 레이어를 효과적으로 핸들링하는 것이 제한적이었습니다.
- **새로운 방식**: **`Animator`** 컴포넌트는 여러 레이어를 통해 독립적으로 애니메이션 클립을 재생하고, 각각의 레이어에서 블렌딩을 구성할 수 있습니다. 이를 통해 더욱 자연스럽고 동적인 캐릭터 움직임을 구현할 수 있습니다.

### **4. 퍼포먼스 및 최적화**

- **기존 방식**: 많은 애니메이션 클립과 복잡한 조건 로직을 코드로 관리할 경우, 성능 이슈가 발생할 수 있습니다.
- **새로운 방식**: **`Animator`** 시스템은 내부적으로 최적화가 잘 되어 있어, 많은 수의 애니메이션과 복잡한 상태 관리를 더 효율적으로 수행할 수 있습니다.

이러한 이유들로 인해, 유니티는 보다 진보된 애니메이션 관리를 위해 **`Animator`** 방식으로의 전환을 선택했습니다. 이는 개발자들에게 더욱 강력하고 유연한 도구를 제공하여, 더 복잡하고 풍부한 게임 경험을 만들 수 있도록 지원합니다.

## 애니메이터 파라메터

유니티의 **`Animator`** 컴포넌트에서 사용하는 파라미터는 애니메이션의 흐름을 제어하는 데 중요한 역할을 합니다. 애니메이터에서 사용할 수 있는 파라미터 타입은 크게 네 가지로 구분됩니다. 각각의 타입은 특정 애니메이션 기능과 상태 전환을 제어하는 데 활용됩니다.

### **1. Float**

- **설명**: 소수 값을 가지는 파라미터입니다. 이 파라미터는 주로 연속적인 값의 변화를 표현할 때 사용됩니다. 예를 들어, 캐릭터의 이동 속도나 각도 등을 조절하는 데 사용될 수 있습니다.
- **용도**: 속도 조절, 거리 계산, 진폭 조절 등 다양한 연속적인 수치 변화를 애니메이션과 연동할 때 사용됩니다.

### **2. Int**

- **설명**: 정수 값을 가지는 파라미터입니다. **`Float`**와 비슷하게 수치 데이터를 기반으로 하지만, 보다 이산적인 값에 사용됩니다. 예를 들어, 무기의 종류나 상태 레벨 등을 지정할 때 사용할 수 있습니다.
- **용도**: 캐릭터의 상태, 무기 선택, 레벨 변경 등 정확한 수치가 필요한 경우에 사용됩니다.

### **3. Bool**

- **설명**: 참(true) 또는 거짓(false)의 두 가지 값만을 가지는 파라미터입니다. 이 파라미터는 주로 조건적인 상황에서 사용되며, 특정 조건이 참인지 거짓인지를 판단하는 데 사용됩니다.
- **용도**: 캐릭터의 특정 동작을 시작하거나 중지할 때, 예를 들어 점프 중인지, 공격 중인지 등의 상태를 표현하는 데 사용됩니다.

### **4. Trigger**

- **설명**: 이벤트 기반의 파라미터로, **`Bool`**과 유사하지만 한 번 사용되고 나면 자동으로 리셋됩니다. **`Trigger`**는 특정 액션이 일어났을 때 한 번만 사용되며, 그 이벤트가 발생하면 관련된 상태 전환을 일으키고 바로 초기화됩니다.
- **용도**: 애니메이션의 특정 시점에서 일회성 이벤트를 발동시키는 데 사용됩니다. 예를 들어, 캐릭터가 특정 조건을 만족했을 때 공격 애니메이션을 시작하는 신호로 사용할 수 있습니다.

이러한 파라미터들은 애니메이터 컨트롤러 내에서 애니메이션 클립 간의 전환 또는 특정 애니메이션 상태의 조건을 제어하는 데 중요한 역할을 합니다. 개발자는 이 파라미터들을 조합하여 복잡한 애니메이션 로직을 구성할 수 있으며, 게임의 다양한 상황에 따라 캐릭터의 움직임을 유연하게 제어할 수 있습니다.

### **파라미터 설정하는 스크립트 예제**

아래는 유니티에서 **`Animator`** 컴포넌트의 파라미터를 스크립트를 통해 설정하는 기본적인 예제입니다. 이 예제에서는 **`Bool`**, **`Float`**, **`Int`**, 그리고 **`Trigger`** 파라미터를 설정하는 방법을 보여줍니다.

```csharp
using UnityEngine;

public class AnimationController : MonoBehaviour
{
    private Animator animator;

    void Start()
    {
        // Animator 컴포넌트를 가져옵니다.
        animator = GetComponent<Animator>();
    }

    void Update()
    {
        // Float 파라미터 설정
        animator.SetFloat("Speed", 5.0f);

        // Int 파라미터 설정
        animator.SetInteger("Health", 100);

        // Bool 파라미터 설정
        animator.SetBool("IsJumping", true);

        // Trigger 파라미터 활성화
        if (Input.GetKeyDown(KeyCode.Space))
        {
            animator.SetTrigger("Jump");
        }
    }
}
```

### **`Animator` 꺼졌다 켜졌을 때의 파라미터 및 상태 리셋**

**`Animator`** 컴포넌트가 비활성화되었다가 다시 활성화될 때, 파라미터 값은 보존되지만, 애니메이션의 상태는 초기 상태로 리셋될 수 있습니다. 이는 유니티의 **`Animator`**가 내부적으로 상태 머신을 다시 시작하기 때문입니다. 따라서, 다음과 같은 상황에서는 주의가 필요합니다:

1. **파라미터 값**: **`Animator`**가 꺼졌다 켜도 **`SetFloat`**, **`SetBool`**, **`SetInteger`** 등으로 설정된 파라미터 값은 유지됩니다. 그러나 **`SetTrigger`**로 설정된 트리거는 활성화되었을 때 바로 사용되고 리셋되므로, **`Animator`**를 다시 활성화할 때는 트리거 상태가 초기화됩니다.
2. **애니메이션 상태**: **`Animator`**가 비활성화되었다가 활성화되면, 애니메이션 상태는 기본 상태(Entry 상태)로 돌아갑니다. 이는 예상치 못한 애니메이션 전환이 발생할 수 있음을 의미합니다.
3. **애니메이션 이벤트**: 애니메이터가 비활성화되는 동안 애니메이션 이벤트는 실행되지 않습니다. 활성화된 후에 이벤트가 발생해야 할 상태를 재구성해야 할 수도 있습니다.

이러한 동작을 이해하고 있으면, **`Animator`** 컴포넌트를 활용할 때 보다 세밀한 제어가 가능하며, 예상치 못한 버그나 문제를 방지할 수 있습니다.

## 애니메이터 레이어

유니티의 **`Animator`** 컴포넌트에서 레이어와 블렌드는 애니메이션을 다층적으로 관리하고, 다양한 애니메이션을 서로 조합할 수 있는 강력한 기능을 제공합니다. 이 기능들은 캐릭터가 더 자연스럽고 복잡한 동작을 할 수 있도록 도와줍니다.

### **애니메이터 레이어**

애니메이터 레이어는 여러 애니메이션 클립을 동시에 재생할 수 있게 해주며, 각 레이어는 독립적인 애니메이션 상태 머신을 가집니다. 이를 통해 개발자는 몸통과 다리와 같이 서로 다른 신체 부위에 다른 애니메이션을 적용할 수 있습니다. 예를 들어, 캐릭터가 달리면서 동시에 총을 겨냥하거나 투구를 할 수 있습니다.

- **기본 레이어**: **`Base Layer`**는 가장 기본이 되는 레이어로, 전체 캐릭터에 영향을 미치는 애니메이션을 처리합니다.
- **추가 레이어**: 이 레이어들은 특정 부분의 애니메이션을 오버라이드하거나 추가적인 애니메이션 효과를 적용하기 위해 사용됩니다. 각 레이어는 'Weight' 설정을 통해 해당 레이어의 애니메이션 영향력을 조절할 수 있습니다.

### **블렌딩 (애니메이션 블렌딩)**

애니메이션 블렌딩은 여러 애니메이션 클립을 서로 부드럽게 전환하거나 혼합하는 기술입니다. 이는 두 가지 주요 방식을 통해 구현됩니다:

1. **1D 블렌딩**: 단일 파라미터에 따라 두 개 이상의 애니메이션을 혼합합니다. 예를 들어, 캐릭터의 이동 속도에 따라 걷기와 달리기 애니메이션을 부드럽게 전환할 수 있습니다.
2. **2D 블렌딩**: 두 개의 파라미터를 사용하여 애니메이션을 혼합합니다. 이는 보통 방향과 속도 같은 두 가지 요소를 동시에 고려할 때 사용됩니다. 예를 들어, 캐릭터가 전후좌우로 이동하면서도 서로 다른 방향을 바라보게 하는 등의 복잡한 동작에 사용됩니다.

### **블렌딩 트리 (Blend Trees)**

블렌드 트리는 복수의 애니메이션 클립을 파라미터에 따라 자동으로 블렌딩하는 기능을 제공하는 도구입니다. 개발자는 블렌드 트리 내에서 여러 클립과 블렌딩 조건을 설정하고, 실행 중에 캐릭터의 움직임에 따라 애니메이션을 실시간으로 조정할 수 있습니다.

애니메이터의 레이어와 블렌딩 기능을 통해 개발자는 더욱 동적이고 실감 나는 캐릭터 애니메이션을 제작할 수 있습니다. 이 기능들은 특히 복잡한 인터랙션이나 자연스러운 캐릭터 움직임을 구현해야 하는 게임에서 매우 중요하며, 게임 내 캐릭터들이 실제 같은 행동을 할 수 있도록 만듭니다. 또한, 이 기능들은 게임 플레이의 질을 높이고, 사용자 경험을 향상시키는 데 큰 역할을 합니다.

### **실용적인 예제**

예를 들어, 게임 내에서 캐릭터가 달리면서 다양한 방향으로 물건을 던지는 애니메이션을 구현하고 싶다고 가정해 보겠습니다. 이런 경우, **`Base Layer`**에서는 달리기 애니메이션을 관리하고, 추가 레이어에서는 던지기 동작을 독립적으로 관리할 수 있습니다. 두 애니메이션 레이어의 'Weight'를 조절하여, 던지기 동작이 달리기 동작에 얼마나 영향을 미칠지 결정할 수 있습니다.

또한, 블렌드 트리를 사용하면 캐릭터의 이동 속도와 방향에 따라 자연스럽게 걷기에서 달리기로, 또는 던지기 동작으로 부드럽게 전환되도록 할 수 있습니다. 이를 통해 캐릭터의 동작이 더욱 실감나고 다양해질 수 있습니다.

### **블렌드 트리의 세부 구성**

블렌드 트리 내에서는 각 애니메이션 클립을 파라미터의 값에 따라 자동으로 혼합할 수 있습니다. 예를 들어, **`speed`**와 **`direction`** 두 파라미터를 사용하여 2D 블렌드 트리를 설정할 수 있고, 이 두 값에 따라 캐릭터의 움직임 방향과 속도가 자연스럽게 반영됩니다. 따라서 개발자는 복잡한 코드를 작성하지 않고도 섬세한 애니메이션 제어를 할 수 있습니다.

### **최종적으로**

유니티의 애니메이터 레이어와 블렌드 기능은 게임 개발에서 캐릭터의 행동과 반응을 미세하게 조정할 수 있게 해주며, 이는 플레이어에게 보다 몰입감 있는 경험을 제공합니다. 복잡한 캐릭터 애니메이션을 효율적으로 관리하고, 게임의 전반적인 품질을 높이는 데 크게 기여합니다.

## 애니메이션 플레이

유니티에서 애니메이션을 처리할 때, 특히 복잡한 캐릭터와 다양한 애니메이션 상태를 관리하다 보면, 디폴트키 설정과 애니메이션 플레이 시 생략된 채널의 초기값 문제가 중요한 이슈로 다뤄집니다. 이 두 가지 측면에 대해 자세히 설명하겠습니다.

### **디폴트키 설정**

디폴트키는 애니메이터 컴포넌트의 애니메이션 클립에서 특정 속성에 대한 기본 값 설정을 의미합니다. 유니티에서 애니메이션 클립을 만들 때, 특정 속성(예: 위치, 회전, 스케일 등)에 대해 처음부터 키 프레임을 지정하지 않으면, 그 속성의 디폴트 값은 애니메이션 클립을 재생하기 전 객체의 현재 상태 또는 인스펙터에서 설정된 초기값을 반영하게 됩니다.

### **이슈**

- **애니메이션 간 속성 불일치**: 만약 여러 애니메이션 클립에서 일부 속성의 키 프레임이 설정되어 있고 일부는 설정되어 있지 않다면, 애니메이션 간 전환 시 해당 속성 값이 예상치 못하게 변할 수 있습니다. 이는 게임 플레이 도중 캐릭터나 객체가 갑작스럽게 "텔레포트" 하거나 "스냅"하는 현상을 유발할 수 있습니다.

### **애니메이션 플레이 시 생략된 채널의 초기값 문제**

애니메이션 클립에서 모든 가능한 속성을 매번 명시적으로 키 프레임에 기록하지 않는 경우가 많습니다. 예를 들어, 어떤 애니메이션 클립은 캐릭터의 팔 움직임만을 다루고, 다른 부분은 영향을 주지 않을 수 있습니다. 이 경우, 해당 애니메이션 클립은 팔 관련 데이터만 포함하고, 다른 부분(예: 다리)은 포함하지 않을 수 있습니다.

### **이슈**

- **애니메이션 클립 간 충돌**: 애니메이션 클립이 다른 클립에 의해 설정된 값에 영향을 받지 않도록 적절히 관리되지 않으면, 이전 클립에서 설정된 값(예: 다리 위치)이 새 클립에서 관리되지 않는 경우 그 값이 유지되어 예상치 못한 동작이 발생할 수 있습니다.
- **애니메이션 불일치**: 예를 들어, 한 애니메이션에서 캐릭터의 다리를 어떤 특정 위치로 이동시켰다가, 다른 애니메이션에서는 다리 위치를 아예 조정하지 않으면, 다리 위치가 첫 번째 애니메이션에서 설정된 마지막 위치에 고정되어 버릴 수 있습니다.

### **해결 방법**

- **전체 속성 키 프레임 설정**: 애니메이션 클립을 생성할 때, 모든 관련 속성에 대해 초기 키 프레임을 설정해 디폴트 값을 명확히 합니다. 이는 애니메이션 간 부드러운 전환과 예측 가능한 동작을 보장하는 데 도움이 됩니다.
- **애니메이션 레이어 활용**: 복잡한 캐릭터 애니메이션을 다룰 때는 애니메이션 레이어를 사용하여 각 부분을 독립적으로 컨트롤할 수 있습니다. 예를 들어, 다리와 팔의 애니메이션을 서로 다른 레이어에서 관리함으로써, 한 부위의 애니메이션 설정이 다른 부위에 영향을 주지 않도록 할 수 있습니다.
- **블렌딩과 블렌드 트리 사용**: 블렌드 트리를 활용하여 여러 애니메이션 클립에서 속성을 부드럽게 혼합하고 전환합니다. 이를 통해 다양한 애니메이션 상태에서 각 속성 값이 어떻게 변화하는지 더 잘 제어할 수 있습니다.
- **애니메이션 클립 초기화 설정**: 각 애니메이션 클립이 시작될 때 필요한 모든 속성을 초기화하도록 설정하여, 이전 애니메이션 클립의 영향을 받지 않도록 합니다. 예를 들어, 클립 시작 부분에 모든 주요 속성에 대해 키 프레임을 배치하여 초기 상태를 명확하게 정의할 수 있습니다.
- **스크립트를 통한 동적 제어**: 게임 로직에서 스크립트를 통해 애니메이션 상태를 실시간으로 조정하고, 필요에 따라 특정 속성을 리셋하거나 조정합니다. 예를 들어, 캐릭터가 새로운 상황이나 환경으로 이동할 때 스크립트를 통해 몸체의 위치나 자세를 조정할 수 있습니다.

이러한 방법들은 개발자가 애니메이션 시스템의 복잡성을 관리하고, 게임 캐릭터의 움직임을 보다 정밀하고 자연스럽게 제어할 수 있도록 도와줍니다. 유니티에서는 이런 이슈들을 효과적으로 해결할 수 있는 다양한 도구와 기능을 제공하여, 개발자가 원하는 대로 캐릭터를 세밀하게 애니메이션할 수 있는 환경을 조성하고 있습니다. 이를 통해 플레이어에게 보다 풍부하고 몰입감 있는 게임 경험을 제공할 수 있습니다.

## IK

FBX 파일 형식은 3D 모델링 소프트웨어에서 널리 사용되는 포맷으로, 메쉬, 애니메이션, 스킨닝 정보 및 리깅 정보 등을 포함할 수 있습니다. 유니티에서 FBX 파일을 사용할 때 리깅 방식과 휴머노이드 설정, 그리고 IK(Inverse Kinematics)를 레이어에 설정하는 방법에 대해 설명하겠습니다.

### **FBX 파일의 리깅 방식**

리깅(rigging)은 3D 캐릭터에게 골격 구조를 제공하고, 이 골격에 따라 캐릭터가 움직일 수 있도록 설정하는 과정을 말합니다. FBX 파일 내에는 다음과 같은 리깅 정보가 포함될 수 있습니다:

- **본(Bones)**: 캐릭터의 골격을 이루는 요소로, 각 본은 캐릭터의 특정 부위를 제어합니다.
- **스킨(Skin)**: 메쉬를 본에 연결하는 과정에서, 메쉬의 각 버텍스(vertex)가 어떤 본에 얼마나 영향을 받을지 결정합니다. 이를 스킨 웨이트(skin weights)라고 합니다.

### **휴머노이드 리깅**

휴머노이드 리깅은 인간형 캐릭터를 위한 특수한 리깅 시스템입니다. 유니티에서는 휴머노이드 리깅을 사용하여 다양한 인간형 캐릭터 간에 애니메이션을 재사용할 수 있습니다. 유니티의 휴머노이드 시스템은 다음과 같은 특징을 가집니다:

- **범용 애니메이션**: 한 캐릭터의 애니메이션을 다른 휴머노이드 캐릭터에 적용할 수 있습니다.
- **본 매핑**: 캐릭터의 본 구조를 휴머노이드의 표준 본 구조에 맞게 매핑합니다. 이 과정에서 팔, 다리, 척추, 머리 등 주요 부위가 매핑됩니다.

유니티에서는 Inverse Kinematics (IK) 시스템이 주로 휴머노이드 캐릭터에 적용되는 경향이 있습니다. 이는 휴머노이드 리깅이 표준화된 본 구조를 가지며, 이 구조를 기반으로 IK 계산이 수행되기 때문입니다. 여기에는 몇 가지 기술적인 이유와 제한이 있습니다.

### **휴머노이드만 IK가 적용되는 이유**

1. **표준화된 본 구조**: 휴머노이드 캐릭터는 유니티에서 표준화된 본 구조를 따릅니다. 이 구조는 팔, 다리, 척추 등 인간의 주요 관절을 모델링하고, 각 관절의 IK 계산을 위한 알고리즘이 미리 설정되어 있습니다.
2. **재사용성**: 휴머노이드 리깅과 IK 시스템의 표준화로 인해, 다른 휴머노이드 캐릭터 간에 애니메이션과 IK 설정을 쉽게 재사용할 수 있습니다. 이는 개발 시간을 절약하고, 다양한 캐릭터에 일관된 애니메이션 품질을 보장합니다.
3. **자동화된 IK 처리**: 휴머노이드 리깅을 사용할 때, 유니티는 손과 발 등의 위치를 자동으로 조정하는 IK 솔버를 내장하고 있어, 개발자가 별도로 복잡한 IK 로직을 구현할 필요가 없습니다.

### **비휴머노이드에 IK 적용의 제한**

비휴머노이드 캐릭터는 표준화된 본 구조를 따르지 않기 때문에, 유니티의 내장 IK 시스템을 사용할 수 없습니다. 이 경우, 개발자는 수동으로 본을 설정하고, 필요에 따라 커스텀 IK 솔루션을 구현해야 할 수도 있습니다. 이는 추가적인 작업량을 의미하며, 때로는 외부 플러그인이나 라이브러리를 활용할 필요가 있습니다.

### **IK 설정 및 레이어에 적용**

IK(Inverse Kinematics)는 목표 위치(예: 손이 특정 지점을 가리키는 위치)를 기반으로 필요한 관절의 각도를 계산하는 방식입니다. 유니티에서는 Animator 컴포넌트와 함께 IK를 설정하여, 보다 자연스러운 움직임을 생성할 수 있습니다.

레이어에 IK를 설정하는 방법은 다음과 같습니다:

1. **Animator 컴포넌트 설정**: Animator 컴포넌트에서 IK를 활용하려면, 우선 해당 기능을 활성화해야 합니다. 이는 Animator 컴포넌트의 설정에서 할 수 있습니다.
2. **스크립트를 통한 IK 적용**: 유니티의 **`Animator`** 클래스는 **`OnAnimatorIK`** 이벤트를 제공합니다. 이 이벤트 내에서, 개발자는 **`SetIKPosition`**과 같은 함수를 사용하여 특정 본(예: 손목)의 위치를 직접 제어할 수 있습니다.
3. **레이어별 IK 적용**: 다양한 애니메이션 레이어에 각기 다른 IK 목표를 설정하여, 캐릭터의 다른 부분이 서로 다르게 움직이도록 할 수 있습니다.

### **IK 사용 예제**

아래는 유니티에서 휴머노이드 캐릭터의 손이 특정 대상(예: 객체)을 향하도록 하는 간단한 IK 사용 예제입니다.

```csharp
using UnityEngine;

public class HandIKControl : MonoBehaviour
{
    public Animator animator;
    public Transform target; // IK 목표 위치

    void OnAnimatorIK(int layerIndex)
    {
        if (animator)
        {
            // IK를 활성화합니다.
            animator.SetIKPositionWeight(AvatarIKGoal.RightHand, 1.0f);
            animator.SetIKRotationWeight(AvatarIKGoal.RightHand, 1.0f);

            // IK 목표 위치와 회전을 설정합니다.
            animator.SetIKPosition(AvatarIKGoal.RightHand, target.position);
            animator.SetIKRotation(AvatarIKGoal.RightHand, target.rotation);
        }
    }
}
```

이 스크립트는 **`Animator`** 컴포넌트와 함께 사용되며, **`OnAnimatorIK`** 함수 내에서 IK를 설정합니다. 이 함수는 애니메이터의 각 레이어에 대해 프레임마다 호출되며, 여기서 손의 위치와 회전을 목표 지점(target)으로 지정하여 손이 그 방향을 향하게 합니다.

IK를 적용하고자 하는 레이어에서 IK가 활성화되어 있는지 확인합니다. 각 레이어의 **`IK Pass`** 옵션이 활성화되어 있어야 해당 레이어에서 IK 계산이 이루어집니다

이 예제를 통해 개발자는 휴머노이드 캐릭터의 손이 객체를 가리키거나 잡는 등의 상호작용을 실시간으로 조정할 수 있습니다. 이러한 IK 기능은 게임 내에서 캐릭터의 동작을 보다 자연스럽고 실감 나게 만드는 데 큰 도움이 됩니다.