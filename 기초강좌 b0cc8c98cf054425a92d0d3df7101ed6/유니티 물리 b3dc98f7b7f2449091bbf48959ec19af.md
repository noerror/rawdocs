# 유니티 물리

유니티에서 물리 시스템은 주로 게임 내 객체들의 실제적인 움직임과 상호작용을 처리하는 데 사용됩니다. 유니티의 물리 시스템은 여러 구성 요소로 이루어져 있는데, 기본적으로 다음과 같은 요소들을 포함합니다:

1. **Rigidbody 컴포넌트**: 이 컴포넌트는 게임 오브젝트에 물리적 속성을 부여합니다. Rigidbody가 부착된 객체는 중력의 영향을 받고, 충돌 및 기타 물리적 힘에 반응합니다. Rigidbody는 두 가지 타입이 있습니다: **`Rigidbody`** (3D)와 **`Rigidbody2D`** (2D).
2. **Collider 컴포넌트**: Collider는 물리적 충돌을 감지하는 구역을 정의합니다. 유니티에는 다양한 형태의 Collider가 있으며, 예를 들어 Box Collider, Sphere Collider, Capsule Collider, Mesh Collider 등이 있습니다. 2D 게임에는 BoxCollider2D, CircleCollider2D 등이 사용됩니다.
3. **Physics Material**: Physics Material은 Collider의 마찰과 반발(탄성)을 정의합니다. 이를 통해 물체가 서로 부딪힐 때 얼마나 미끄러지거나 튀는지 설정할 수 있습니다.
4. **Joint 컴포넌트**: Joint는 물리적으로 서로 연결된 두 객체 사이의 상호 작용을 정의합니다. 예를 들어 Hinge Joint, Spring Joint, Fixed Joint 등이 있으며, 이를 사용하여 복잡한 물리적 상호작용이나 구조를 만들 수 있습니다.
5. **Physics Engine 설정**: 유니티의 Physics Engine은 전반적인 물리 시스템의 동작 방식을 제어합니다. 이 설정을 통해 중력의 강도, 시뮬레이션의 정밀도, 타임 스텝 등을 조절할 수 있습니다.

유니티의 물리 시스템은 이러한 구성 요소들을 통해 매우 다양하고 복잡한 물리적 상호작용을 실시간으로 처리하고, 개발자가 비교적 쉽게 인터랙티브한 게임 환경을 구축할 수 있도록 도와줍니다.

## Rigidbody

유니티에서 **`Rigidbody`** 컴포넌트는 객체가 물리 시뮬레이션에 참여하는 방식을 결정하는 중요한 역할을 합니다. **`Rigidbody`**는 주로 세 가지 주요 타입으로 구분됩니다: 정적(Static), 동적(Dynamic), 그리고 키네마틱(Kinematic)입니다.

### **1. 정적 (Static)**

- **정적 타입**은 유니티 내에서 직접 **`Rigidbody`** 컴포넌트를 사용하지 않는 객체를 의미합니다. 이러한 객체는 움직이지 않으며, 물리 시스템에서도 움직임을 계산하지 않습니다. 정적 객체는 주로 환경 구성 요소로 사용됩니다 (예: 바닥, 벽).

### **2. 동적 (Dynamic)**

- **동적 타입**은 **`Rigidbody`** 컴포넌트가 추가된 객체로, 중력 및 외부 힘에 반응합니다. 이 객체들은 충돌 및 다른 물리적 상호작용을 통해 실시간으로 위치와 회전이 변경될 수 있습니다.

### **3. 키네마틱 (Kinematic)**

- **키네마틱 타입**은 **`Rigidbody`**의 **`isKinematic`** 속성을 활성화하여 사용합니다. 키네마틱 Rigidbody는 중력이나 충돌로 인한 자동 계산 대신, 스크립트나 애니메이션에 의해서만 움직임이 제어됩니다. 이는 움직이는 플랫폼 또는 제어된 물체에 유용합니다.

### **Rigidbody의 주요 입력 가능한 파라메터:**

- **Mass**: 물체의 질량입니다. 더 무거운 객체는 더 적게 가속됩니다.
- **Drag**: 공기 저항 또는 물 속에서의 저항을 모사합니다. 이 값이 클수록 객체는 더 빨리 멈춥니다.
- **Angular Drag**: 회전할 때의 저항을 설정합니다. 이 값도 클수록 회전이 더 빨리 줄어듭니다.
- **Use Gravity**: 이 옵션을 활성화하면 객체가 중력의 영향을 받습니다.
- **Is Kinematic**: 이 옵션을 활성화하면 물리 엔진이 위치와 회전을 자동으로 계산하지 않습니다.
- **Interpolate**: 물리 계산 사이의 프레임을 보간하여 더 부드러운 애니메이션을 제공합니다.
- **Collision Detection**: 충돌 검출 방식을 설정합니다. **`Discrete`** (기본값), **`Continuous`**, **`Continuous Dynamic`** 등이 있으며, 보다 정밀한 충돌 처리가 필요할 때 사용합니다.
- **Constraints**: 위치나 회전을 축에 따라 제한할 수 있습니다. 예를 들어, X축으로만 움직이게 하거나 회전을 금지할 수 있습니다.

이러한 파라메터들은 게임 내에서 물체의 물리적 행동을 세밀하게 조절할 수 있게 해줍니다. 게임의 요구에 따라 적절히 조정하여 원하는 물리적 상호작용을 구현할 수 있습니다.

유니티의 **`Rigidbody`** 컴포넌트는 물리 시뮬레이션에서 중요한 역할을 하며, 이를 통해 속도, 힘, 토크와 같은 다양한 물리적 개념을 구현하고 조작할 수 있습니다. 각 요소에 대해 자세히 알아보겠습니다:

### **속도 (Velocity)**

- **속도**는 객체가 얼마나 빨리 움직이는지를 나타내며, 방향도 포함합니다. 유니티에서는 **`Rigidbody`**의 **`velocity`** 속성을 통해 객체의 속도를 직접 설정하거나 수정할 수 있습니다. 이 속성은 벡터(Vector) 형태로, X, Y, Z 축에 대한 속도를 각각 설정할 수 있습니다. 예를 들어, 물체를 앞으로 밀어내려면 해당 방향의 벡터로 속도를 설정하면 됩니다.

### **힘 (Force)**

- **힘**은 물체에 작용하여 속도를 변경하는 원인이 됩니다. 유니티에서는 다양한 방식으로 힘을 물체에 적용할 수 있습니다:
    - **`AddForce(Vector3 force)`**: 지정한 방향과 크기로 힘을 추가합니다. 이는 물체의 질량을 고려하여 속도를 변경합니다.
    - **`AddForce(Vector3 force, ForceMode mode)`**: 힘을 추가하는 방식을 지정할 수 있습니다. **`ForceMode`**에는 **`Force`** (기본값, 질량을 고려한 가속), **`Acceleration`** (질량을 무시하고 가속), **`Impulse`** (순간적인 힘, 질량 고려), **`VelocityChange`** (질량 무시하고 속도 변경) 등이 있습니다.

### **토크 (Torque)**

- **토크**는 물체를 회전시키는 데 사용됩니다. 토크는 회전을 유발하는 힘으로, 회전축과 그 축을 중심으로 한 회전력의 크기를 결정합니다. 유니티에서 **`Rigidbody`**의 **`AddTorque(Vector3 torque)`** 함수를 사용하여 물체에 토크를 적용할 수 있습니다. 토크 역시 **`ForceMode`**를 사용하여 그 적용 방식을 조절할 수 있으며, 물체의 관성과 회전 저항도 영향을 미칩니다.

이러한 요소들을 조합하고 조절함으로써, 유니티에서 다양한 물리적 상호작용과 동적인 환경을 효과적으로 구현할 수 있습니다. 예를 들어, 자동차에 가속 힘을 가하거나, 공을 던지거나, 회전하는 문을 만드는 등의 행동이 이에 해당됩니다.

## 충돌체 (Collider)

유니티에서 **`Rigidbody`** 컴포넌트와 관련된 충돌체(Colliders)는 물리적 상호작용을 정의하는 데 중요한 역할을 합니다. 충돌체는 물리 시뮬레이션에서 객체가 어떻게 충돌하고 상호 작용할지를 결정합니다. 다음은 유니티의 **`Rigidbody`**와 함께 사용되는 주요 충돌체 특성입니다:

### **1. 충돌체의 종류**

- **Box Collider**, **Sphere Collider**, **Capsule Collider** 등은 간단한 형태의 충돌 검출을 위해 사용되며, 물리 계산을 최적화하는 데 유리합니다.
- **Mesh Collider**는 객체의 정밀한 형태에 따라 충돌을 검출하지만, 계산 비용이 높고 복잡한 메시 형태에서는 사용하기 어려울 수 있습니다. Mesh Collider는 복잡한 형태의 정적 객체에 주로 사용되며, 동적 Rigidbody에 사용할 경우 성능 저하를 일으킬 수 있습니다.

### **2. Mesh Collider의 제한사항**

- **Mesh Collider**는 **`Rigidbody`**가 동적일 때는 사용할 수 없다는 중요한 제한이 있습니다. 메시 컬라이더를 동적으로 사용하려면 **`Convex`** 옵션을 활성화해야 하며, 이 경우 메시의 형태가 볼록 형태로 제한됩니다. 복잡한 내부 구조를 가진 객체에는 적합하지 않을 수 있습니다.

### **3. 복수의 충돌체**

- 하나의 **`Rigidbody`**에 여러 개의 충돌체를 부착할 수 있습니다. 이를 통해 복잡한 형태의 객체도 물리적으로 정확하게 시뮬레이션 할 수 있습니다. 예를 들어, 하나의 차량 객체에 여러 개의 Box Collider를 사용하여 차체, 문, 범퍼 등을 각각 모델링할 수 있습니다.

### **4. Collider의 물리 속성**

- **Physics Material**: Collider에는 Physics Material을 설정하여 물체의 마찰과 반발력(반동) 특성을 조정할 수 있습니다. 이를 통해 물체가 다른 물체와 충돌했을 때 얼마나 미끄러지거나 튀어오를지 결정할 수 있습니다.

### **5. 충돌 감지**

- **Trigger**와 **Collision**: Collider는 **`isTrigger`** 속성을 활용하여 일반적인 물리 충돌이 아닌 트리거 이벤트를 발생시킬 수 있습니다. 이 경우 물리적 충돌 대신에 객체가 서로 겹칠 때 이벤트를 처리할 수 있어, 예를 들어 게임에서 특정 영역에 진입했을 때 점수를 얻는 등의 로직을 구현할 수 있습니다.

이러한 충돌체의 특성과 설정을 적절히 조합하고 활용하면, 유니티 내에서 다양한 물리적 상호작용과 정밀한 충돌 처리가 가능해집니다. 이를 통해 게임이나 시뮬레이션의 실감나고 정확한 물리 환경을 구축할 수 있습니다.

## 트리거 (Trigger)

유니티에서 **`트리거`**는 특별한 유형의 충돌 감지 메커니즘으로, 물리적 충돌 대신에 객체가 특정 영역에 들어오거나 나갈 때 이벤트를 발생시키는데 사용됩니다. 트리거를 사용하려면, 충돌체(Collider)에 **`isTrigger`** 속성을 설정해야 합니다. 이 설정이 활성화되면, 충돌체는 더 이상 실제 물리적 충돌을 하지 않고 '트리거 이벤트'를 발생시키게 됩니다.

### **트리거의 작동 방식**

- 객체가 트리거로 설정된 충돌체 영역에 들어오거나 나갈 때, 유니티는 특정 함수를 호출합니다. 이 함수들은 **`OnTriggerEnter`**, **`OnTriggerExit`**, 그리고 **`OnTriggerStay`**로, 각각 영역에 진입할 때, 나갈 때, 그리고 영역 안에 머무르는 동안 발생합니다.

### **`Rigidbody`와의 관계**

- 트리거 이벤트를 정확하게 감지하기 위해서는 관련된 객체 중 적어도 하나에 **`Rigidbody`** 컴포넌트가 있어야 합니다. 이는 유니티의 물리 엔진이 **`Rigidbody`**를 갖는 객체만을 물리 시뮬레이션의 일부로 계산하기 때문입니다.
- 트리거를 사용할 때 **`Rigidbody`**의 동적인 움직임(예: 중력, 힘의 적용)은 트리거 이벤트의 발생에 영향을 주지 않습니다. 즉, **`isTrigger`**가 활성화된 충돌체는 물리적인 충돌을 계산하지 않기 때문에, Rigidbody가 가해지는 힘에 의한 움직임과는 독립적으로 트리거 이벤트만을 발생시킵니다.

### **트리거 사용 예**

- 게임 내에서 아이템을 수집하는 영역, 특정 지점을 통과하는 체크포인트, 또는 위험 구역에 진입했을 때 경고를 주는 등의 기능을 구현할 때 주로 사용됩니다.
- 예를 들어, 플레이어가 아이템을 수집하는 영역에 진입하면 **`OnTriggerEnter`**를 통해 아이템을 자동으로 수집하고, 해당 아이템을 게임 세계에서 제거할 수 있습니다.

### **주의점**

- **`Rigidbody`**의 **`isKinematic`** 속성이 활성화된 경우, 그 객체는 물리 엔진에 의해 움직이지 않으므로, 트리거 이벤트는 스크립트나 애니메이션 등 다른 수단으로 객체를 움직일 때만 발생할 수 있습니다.
- 또한, 트리거 충돌체 자체가 움직이지 않으면, 트리거 이벤트는 다른 움직이는 객체가 해당 영역에 들어왔을 때만 발생합니다.

이러한 특성 덕분에 트리거는 게임 개발에서 매우 유용하게 쓰이며, 복잡한 물리적 상호작용 없이도 객체 간의 상호 작용을 감지하고 처리할 수 있습니다.

## 충돌의 연속성

유니티에서 발생할 수 있는 주요 이슈 중 하나는 "터널링"이라고도 불리는 현상입니다. 이는 빠르게 움직이는 객체가 다른 객체를 관통해 버리는 문제로, 특히 물리 계산이 이루어지는 프레임 간격에 객체가 너무 멀리 이동했을 때 일어납니다. 유니티는 이러한 문제를 해결하기 위해 여러 가지 방법을 제공합니다.

### **터널링 (Tunneling)**

터널링은 고속으로 움직이는 객체가 충돌 감지를 '빠져나가는' 현상입니다. 예를 들어, 총알이 빠르게 날아가며 타겟을 뚫고 지나가 버리는 경우가 이에 해당합니다. 이는 충돌 감지가 프레임마다 이루어지므로, 한 프레임에서 다음 프레임으로 넘어갈 때 충돌체 사이의 거리가 충분히 멀다면 충돌이 감지되지 않을 수 있습니다.

### **CCD (Continuous Collision Detection)**

CCD는 Continuous Collision Detection의 약자로, 터널링 문제를 해결하기 위한 기술입니다. CCD는 충돌 검사를 좀 더 세밀하게 진행하여 고속으로 움직이는 객체가 다른 객체를 관통하는 것을 방지합니다. 유니티에서는 **`Rigidbody`** 컴포넌트에 **`Collision Detection`** 옵션을 설정하여 이 기능을 활성화할 수 있습니다.

### **Collision Detection 설정**

유니티의 **`Rigidbody`** 컴포넌트에서는 다음과 같은 충돌 감지 방법을 설정할 수 있습니다:

- **Discrete (기본 설정)**: 가장 기본적인 충돌 감지 방식으로, 성능은 좋지만 고속으로 움직이는 객체에서는 터널링 문제가 발생할 수 있습니다.
- **Continuous**: 이 설정은 특정 객체에 대해 연속적인 충돌 감지를 활성화하여 터널링을 방지합니다. 주로 플레이어 캐릭터나 중요한 게임 오브젝트에 적용됩니다.
- **Continuous Dynamic**: 가장 강력한 충돌 감지 방식으로, 고속으로 움직이는 모든 객체에 대해 연속적인 충돌 감지를 수행합니다. 이 설정은 계산 비용이 매우 높으므로 필요한 경우에만 사용해야 합니다.

### **사용상의 고려 사항**

- CCD를 사용하면 성능에 영향을 줄 수 있으므로, 필요한 객체에만 적절하게 적용하는 것이 중요합니다.
- 작은 크기의 빠른 총알과 같은 객체는 **`Raycast`**나 다른 방법을 사용하여 수동으로 충돌 감지를 처리하는 것이 더 효율적일 수 있습니다.

터널링 문제와 CCD 설정은 유니티 내에서 물리적 상호작용의 정확성을 극대화하기 위한 중요한 요소입니다. 게임의 물리적 현실감을 높이고, 예기치 못한 물리적 오류로 인한 게임플레이의 문제를 방지하기 위해 적절히 활용되어야 합니다.

## 레이케스트 (RayCast)

유니티에서 직접 충돌 검사를 수행하는 데 사용되는 기본적인 기술에는 **`레이케스트(Raycast)`**와 **`스윕 테스트(Sweep Test)`**가 포함됩니다. 이들은 특히 고속으로 움직이는 객체의 터널링 문제를 예방하거나, 복잡한 환경에서 정밀한 충돌 감지가 필요할 때 사용됩니다. 각각의 기능을 설명하겠습니다:

### **1. 레이케스트 (Raycast)**

레이케스트는 한 점에서 특정 방향으로 가상의 "선"을 발사하여 그 선이 어떤 물체와 충돌하는지를 검사하는 방법입니다. 이는 투사체, 시야 검사, 마우스 클릭에 의한 객체 선택 등 다양한 용도로 활용됩니다.

- **사용법**: **`Physics.Raycast`** 함수를 사용하며, 주로 다음과 같은 파라미터를 필요로 합니다:
    - **Ray**: 충돌 검사를 시작할 위치와 방향을 나타내는 **`Ray`** 객체.
    - **hitInfo**: 레이가 충돌한 객체에 대한 정보를 저장하는 **`RaycastHit`** 객체. 충돌한 위치, 거리, 노멀 등의 정보를 포함합니다.
    - **maxDistance**: 레이를 쏠 최대 거리. 이 거리를 넘어선 충돌은 감지하지 않습니다.
    - **layerMask**: 특정 레이어에만 충돌을 감지하도록 설정할 수 있습니다. 레이어를 사용하여 불필요한 충돌 검사를 줄일 수 있습니다.

예제 코드:

```csharp
RaycastHit hit;
if (Physics.Raycast(transform.position, transform.forward, out hit, 100.0f)) {
    Debug.Log("Hit " + hit.collider.gameObject.name);
}
```

### **2. 스윕 테스트 (Sweep Test)**

스윕 테스트는 물체를 일정 경로로 이동시켰을 때 그 경로 상에 있는 다른 객체와의 충돌을 감지하는 방법입니다. 이는 주로 크기가 큰 물체의 움직임을 시뮬레이션할 때 사용됩니다.

- **사용법**: **`Rigidbody`** 컴포넌트가 필요하며, **`Rigidbody.SweepTest`** 함수를 사용합니다. 이 함수는 물체의 경로를 따라 가상의 이동을 시뮬레이션하여 충돌을 감지합니다.
    - **direction**: 이동할 방향을 나타내는 벡터.
    - **hitInfo**: 충돌 정보를 받을 **`RaycastHit`** 객체.
    - **maxDistance**: 최대 검사 거리.

예제 코드:

```csharp
Rigidbody rb = GetComponent<Rigidbody>();
RaycastHit hit;
if (rb.SweepTest(transform.forward, out hit, 10.0f)) {
    Debug.Log("Sweep hit: " + hit.collider.gameObject.name);
}
```

이 두 기술은 유니티 게임 개발에서 매우 유용하게 사용되며, 특히 물리적 충돌의 정밀한 검사와 관리가 중요한 경우에 필수적입니다. 각각의 목적과 상황에 맞게 적절히 선택하여 사용해야 합니다.

유니티에서 레이케스트 또는 스윕 테스트를 통해 충돌을 검사했을 때, 충돌 결과에는 여러 유용한 정보가 포함되어 있습니다. 이 정보는 충돌에 대한 상세한 분석을 가능하게 하고, 게임 로직의 구현에 필수적인 요소를 제공합니다. 다음은 충돌 결과(**`RaycastHit`** 객체)에서 얻을 수 있는 주요 정보들입니다:

### **1. 위치 (Point)**

- **Point**: 충돌이 발생한 정확한 위치를 **`Vector3`** 형식으로 제공합니다. 이는 월드 좌표계에서의 포인트를 나타내며, 충돌이 일어난 지점의 위치를 알려줍니다.

### **2. 거리 (Distance)**

- **Distance**: 레이의 시작 지점부터 충돌 지점까지의 거리를 나타냅니다. 이 값은 레이를 쏜 시작점으로부터 충돌 지점까지의 선형 거리를 미터 단위로 제공하며, 거리 계산이나 충돌 처리 로직에서 유용하게 사용될 수 있습니다.

### **3. 노멀 (Normal)**

- **Normal**: 충돌 지점에서의 표면의 노멀(법선) 벡터를 나타냅니다. 이 벡터는 충돌한 표면이 가리키는 방향을 나타내며, 충돌 후의 반사, 튕김 등의 물리적 처리를 계산하는 데 필수적입니다.

### **4. 충돌한 오브젝트 (Collider)**

- **Collider**: 충돌한 오브젝트의 **`Collider`** 컴포넌트에 대한 참조를 제공합니다. 이를 통해 충돌한 객체의 다른 속성에 접근하거나, 특정 오브젝트와의 상호작용을 구현할 수 있습니다.

### **5. 리지드바디 (Rigidbody)**

- **Rigidbody**: 충돌한 오브젝트가 **`Rigidbody`** 컴포넌트를 가지고 있다면, 이 컴포넌트에 대한 참조도 제공됩니다. 이를 통해 충돌한 오브젝트의 물리적 속성을 조절하거나, 물리적 반응을 구현할 수 있습니다.

### **6. 트랜스폼 (Transform)**

- **Transform**: 충돌한 오브젝트의 **`Transform`** 컴포넌트에 대한 참조를 제공합니다. 이 정보를 사용하여 객체의 위치, 회전, 크기 등을 변경할 수 있습니다.

### **예제 코드 사용**

```csharp
RaycastHit hit;
if (Physics.Raycast(transform.position, transform.forward, out hit, 100.0f)) {
    Debug.Log("Hit point: " + hit.point);
    Debug.Log("Hit distance: " + hit.distance);
    Debug.Log("Hit normal: " + hit.normal);
    Debug.Log("Hit object: " + hit.collider.gameObject.name);
}
```

이러한 충돌 정보는 유니티에서 충돌 감지를 통한 다양한 게임 로직과 물리적 반응을 정밀하게 처리하는 데 중요한 역할을 합니다. 충돌 결과를 통해 얻은 정보를 바탕으로 플레이어의 상호작용, 객체의 파괴, 충돌에 따른 이벤트 트리거 등을 구현할 수 있습니다.

유니티에서 2D 게임 개발을 위한 충돌 검사 중 하나로 **`2D Raycast`**가 널리 사용됩니다. 이 방법은 특정 방향으로 가상의 선(레이)을 발사하여 그 선이 어떤 2D 콜라이더와 충돌하는지를 검사합니다. 2D 레이케스트는 플랫폼 게임, 슈팅 게임 등 다양한 2D 게임에서 캐릭터의 시야, 발사체의 충돌, 플레이어의 마우스 클릭에 의한 객체 선택 등 여러 상황에서 사용됩니다.

### **기본 사용법**

**`Physics2D.Raycast`** 함수를 사용하여 2D 레이케스트를 실행합니다. 이 함수는 다음과 같은 주요 파라미터를 받습니다:

- **origin**: 레이케스트가 시작되는 위치(Vector2).
- **direction**: 레이케스트가 진행되는 방향(Vector2). 방향은 일반적으로 정규화된 벡터(normalized vector)로 제공됩니다.
- **distance**: 레이케스트가 검사할 거리. 생략하거나 무한대로 설정할 수 있습니다.
- **layerMask**: 레이케스트가 충돌을 검사할 레이어. 특정 레이어만을 대상으로 충돌 검사를 제한하고 싶을 때 사용합니다.

### **반환 값**

**`Physics2D.Raycast`**는 **`RaycastHit2D`** 객체를 반환합니다. 이 객체는 충돌이 발생했을 때 다음과 같은 정보를 포함합니다:

- **point**: 충돌 지점의 위치(Vector2).
- **normal**: 충돌 지점에서의 충돌 표면의 법선 벡터(Vector2).
- **distance**: 충돌 지점까지의 거리.
- **collider**: 충돌한 객체의 **`Collider2D`** 컴포넌트.
- **rigidbody**: 충돌한 객체의 **`Rigidbody2D`** 컴포넌트(있을 경우).
- **transform**: 충돌한 객체의 **`Transform`** 컴포넌트.

### **예제 코드**

다음은 유니티에서 레이케스트를 사용하여 충돌을 검사하고, 충돌 정보를 출력하는 간단한 예제 코드입니다:

```csharp
void Update() {
    Vector2 origin = transform.position; // 레이케스트 시작 위치
    Vector2 direction = transform.right; // 오브젝트의 오른쪽 방향

    float distance = 10f; // 레이케스트 거리
    RaycastHit2D hit = Physics2D.Raycast(origin, direction, distance);

    if (hit.collider != null) {
        Debug.Log("Hit something: " + hit.collider.name);
        Debug.Log("Hit point: " + hit.point);
        Debug.Log("Hit normal: " + hit.normal);
        Debug.Log("Hit distance: " + hit.distance);
    }
}
```

2D 레이케스트는 매우 유연하며, 다양한 2D 게임 개발 상황에서 정밀한 충돌 검사 및 상호작용을 구현할 수 있게 해줍니다. 이를 통해 게임의 반응성을 높이고, 플레이어와의 상호작용을 더 자연스럽게 만들 수 있습니다.

## 레이어(Layer)

유니티에서 레이어(Layers)는 오브젝트를 구분하고, 특정 오브젝트 그룹에 대한 처리를 간편하게 하기 위한 시스템입니다. 물리 시스템에서 레이어를 사용하는 주된 목적은 충돌 검사를 특정 그룹의 오브젝트들로 제한하여 성능을 최적화하고, 게임 로직에 맞추어 충돌을 관리하는 것입니다. 레이어를 통해 물리 계산의 복잡성을 줄이고, 필요한 충돌만을 처리할 수 있습니다. 여기 몇 가지 활용 예를 들어 보겠습니다:

### **1. 충돌 감지 제한**

게임에서는 모든 오브젝트 간의 충돌이 필요하지 않을 수 있습니다. 예를 들어, 플레이어와 환경은 충돌해야 하지만, 적과 적의 미사일은 서로 충돌할 필요가 없을 수 있습니다. 이 경우, 레이어를 사용하여 충돌을 감지할 오브젝트 그룹을 정의하고, 유니티의 Physics Manager에서 레이어간 충돌 가능성을 설정할 수 있습니다. 이를 통해 불필요한 충돌 검사를 줄이고 성능을 개선할 수 있습니다.

### **2. 레이케스트 필터링**

레이케스트를 사용할 때, 모든 오브젝트를 대상으로 하지 않고 특정 레이어에 속한 오브젝트만을 검사할 수 있습니다. 예를 들어, 플레이어가 쏘는 레이케스트가 적 캐릭터만을 감지하게 하고 싶다면, 적 캐릭터를 'Enemies' 레이어에 할당하고, 레이케스트 함수에서 이 레이어만을 대상으로 설정할 수 있습니다. 이 방법은 특정 타입의 오브젝트만을 대상으로 빠른 처리를 할 때 유용합니다.

### **3. 시각적 요소와 물리적 충돌 분리**

때로는 시각적 요소는 보이지만 물리적인 충돌은 하지 않는 오브젝트가 필요할 수 있습니다. 예를 들어, 게임의 배경이나 투명한 장애물 등이 이에 해당합니다. 이런 오브젝트들을 'Background'나 'Non-Collidable' 레이어에 할당하여 물리 시스템에서 이들을 무시하도록 설정할 수 있습니다.

### **4. AI 감지 메커니즘**

AI 캐릭터가 주변 환경을 인지하는 데 레이케스트나 스윕 테스트를 사용할 때, 레이어를 활용하여 AI가 감지해야 할 대상을 구분할 수 있습니다. 예를 들어, 플레이어나 중요 오브젝트만을 'Interactable' 레이어에 두고, AI의 감지 로직에서는 이 레이어만을 대상으로 검사를 수행하게 할 수 있습니다.

### **5. 특정 이벤트 트리거**

트리거 오브젝트를 사용하여 특정 지역에 들어왔을 때 이벤트를 발생시킬 수 있으며, 레이어를 이용해 어떤 종류의 오브젝트가 트리거를 활성화할지 결정할 수 있습니다. 예를 들어, 플레이어 캐릭터만이 특정 지역에 들어왔을 때 문을 열거나, 비밀 메시지를 보여주는 이벤트를 활성화하고자 할 때, 플레이어 캐릭터를 'Player' 레이어에 할당하고, 트리거 콜라이더의 설정에서 이 레이어만을 반응하도록 설정할 수 있습니다. 이렇게 하면 다른 오브젝트가 트리거 지역에 들어와도 이벤트가 발생하지 않습니다.

### **6. 물리 시뮬레이션 제어**

특정 게임 오브젝트 그룹에 대해 다른 물리적 특성을 적용하고자 할 때, 레이어를 활용하여 그룹별로 다른 물리 재질(Physics Material)을 적용할 수 있습니다. 예를 들어, 'Icy' 레이어에 있는 오브젝트들은 미끄러운 물리 재질을 적용하여 플레이어와 다른 캐릭터들이 이 위에서 미끄러지는 효과를 경험하게 할 수 있습니다.

### **7. 멀티레이어 충돌 관리**

대규모 게임 환경에서는 여러 레이어를 조합하여 복잡한 충돌 관리를 수행할 수 있습니다. 예를 들어, 'Players', 'Enemies', 'Bullets', 'Walls' 등의 다양한 레이어를 사용하여 각 그룹별 충돌 동작을 세밀하게 설정할 수 있습니다. 이를 통해 플레이어의 총알은 적과 충돌하고, 적의 총알은 플레이어와 충돌하지만, 적과 적의 총알은 서로 충돌하지 않도록 설정할 수 있습니다.

### **8. 성능 최적화**

레이어를 효과적으로 사용함으로써 게임의 성능을 최적화할 수 있습니다. 불필요한 충돌 검사를 최소화함으로써 CPU 부하를 줄이고, 게임의 프레임 속도를 향상시킬 수 있습니다. 특히 모바일 게임이나 리소스가 제한된 환경에서 성능 개선은 매우 중요합니다.

레이어는 유니티 게임 개발에서 강력한 도구로, 효율적인 게임 논리 구현 및 성능 최적화를 가능하게 합니다. 각기 다른 게임 개발 시나리오에서 레이어를 적절하게 활용하여, 보다 정교하고 효율적인 게임을 만들 수 있습니다.

### **레이어가 32개인 이유**

유니티의 레이어 시스템에서 레이어는 최대 32개로 제한됩니다. 이 제한은 레이어의 표현과 관리를 위해 비트 마스킹 기법을 사용하기 때문입니다. 비트 마스킹은 각 레이어를 하나의 비트로 표현하며, 32개의 비트로 이루어진 정수 하나로 최대 32개의 레이어를 효과적으로 표현할 수 있습니다. 이 방식은 메모리 사용을 최소화하고, 충돌 검사와 같은 연산에서 빠른 처리가 가능하게 합니다.

### **인덱스로 저장되는 이유**

유니티에서 레이어는 주로 인덱스를 통해 참조됩니다. 각 레이어에 이름이 있지만, 내부적으로는 0부터 31까지의 인덱스로 관리됩니다. 이는 충돌 계산 로직을 더 빠르고 간단하게 만들기 위함입니다. 비트 연산을 사용해 레이어 간의 충돌 가능 여부를 판단할 때, 인덱스를 사용하면 복잡한 문자열 비교 대신 간단한 숫자 연산으로 처리할 수 있기 때문에 성능이 향상됩니다.

### **다른 프로젝트로 이동 시 주의사항**

레이어 설정을 다른 유니티 프로젝트로 이동할 때는 몇 가지 주의사항이 있습니다:

1. **레이어 설정 일치**: 다른 프로젝트로 레이어 설정을 이동할 때는 해당 프로젝트의 **`TagManager.asset`** 파일을 직접 복사하거나, 레이어 설정을 수동으로 일치시켜야 합니다. 레이어가 인덱스에 의해 참조되므로, 이동한 프로젝트에서 레이어 인덱스가 원본 프로젝트와 다르게 설정되어 있다면, 충돌 처리나 레이어 기반 로직이 의도한 대로 동작하지 않을 수 있습니다.
2. **스크립트와의 호환성**: 레이어를 활용하는 스크립트가 있다면, 레이어 인덱스나 이름이 정확히 일치하는지 확인해야 합니다. 레이어 인덱스가 하드코딩되어 있는 경우, 이동한 프로젝트에서 인덱스를 수정해야 할 수도 있습니다.
3. **테스트 및 검증**: 레이어 설정을 변경한 후에는 반드시 충돌 검사와 레이어 기반 기능이 올바르게 동작하는지 테스트해야 합니다. 이는 레이어 기반 로직에 의존하는 기능들이 예상대로 동작하는지 확인하기 위함입니다.

레이어 시스템은 유니티 내에서 매우 중요한 역할을 하며, 게임의 물리적 상호작용과 성능 최적화에 큰 영향을 미칩니다. 따라서 레이어를 관리할 때는 신중하게 접근하고, 프로젝트 간이동할 때는 설정의 일관성을 유지하는 것이 매우 중요합니다.

## 레이어 마스크 (LayerMask)

레이어 마스크는 유니티의 물리 시스템에서 특정 레이어에만 충돌이 발생하도록 설정할 때 유용하게 사용됩니다. 예를 들어, 레이케스트, 충돌 검사, 트리거 이벤트 등에서 특정 레이어를 대상으로만 이벤트를 처리하고자 할 때 레이어 마스크를 설정할 수 있습니다.

### **레이어 마스크 생성하기**

유니티에서 레이어 마스크를 생성하는 가장 간단한 방법은 **`LayerMask.GetMask`** 함수를 사용하는 것입니다. 이 함수는 레이어 이름의 배열을 입력으로 받아 해당 레이어들을 포함하는 마스크를 반환합니다.

### **사용 방법**

1. **레이어 이름을 문자열 배열로 정의합니다.**
2. **`LayerMask.GetMask` 함수를 사용하여 레이어 마스크를 생성합니다.**

### **예제 코드**

다음은 "Player", "Enemy", "Obstacle"라는 세 개의 레이어를 포함하는 레이어 마스크를 생성하는 예제 코드입니다:

```csharp
using UnityEngine;

public class Example : MonoBehaviour
{
    void Start()
    {
        // 레이어 마스크 생성
        int layerMask = LayerMask.GetMask("Player", "Enemy", "Obstacle");

        // 레이어 마스크를 사용하는 레이케스트
        RaycastHit hit;
        if (Physics.Raycast(transform.position, transform.forward, out hit, 100, layerMask))
        {
            Debug.Log("Hit " + hit.collider.name);
        }
    }
}
```

이 코드는 "Player", "Enemy", "Obstacle" 레이어 중 하나에 속하는 객체에 대해서만 레이케스트가 충돌을 감지하도록 설정합니다.

### **주의사항**

- **레이어 이름이 정확해야 합니다.** **`LayerMask.GetMask`**는 문자열로 레이어 이름을 입력받기 때문에, 레이어 이름이 정확히 일치하지 않으면 함수가 올바른 마스크를 반환하지 않습니다.
- **레이어는 미리 설정되어 있어야 합니다.** **`LayerMask.GetMask`** 함수를 사용하기 전에 유니티 에디터에서 해당 레이어가 설정되어 있어야 합니다.

레이어 마스크를 사용하면 유니티에서 레이어 기반의 로직을 효과적으로 구현할 수 있으며, 불필요한 충돌 검사를 줄여 성능을 최적화할 수 있습니다. 이 기능은 유니티의 물리 시스템을 보다 효율적으로 사용할 수 있게 해주는 중요한 도구 중 하나입니다.